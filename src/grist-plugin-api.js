var grist =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./_build/core/app/plugin/grist-plugin-api.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./_build/core/app/plugin/CustomSectionAPI-ti.js":
/*!*******************************************************!*\
  !*** ./_build/core/app/plugin/CustomSectionAPI-ti.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CustomSectionAPI = exports.WidgetColumnMap = exports.InteractionOptions = exports.InteractionOptionsRequest = exports.ColumnsToMap = exports.ColumnToMap = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.ColumnToMap = t.iface([], {\n    \"name\": \"string\",\n    \"title\": t.opt(t.union(\"string\", \"null\")),\n    \"type\": t.opt(\"string\"),\n    \"optional\": t.opt(\"boolean\"),\n    \"allowMultiple\": t.opt(\"boolean\"),\n});\nexports.ColumnsToMap = t.array(t.union(\"string\", \"ColumnToMap\"));\nexports.InteractionOptionsRequest = t.iface([], {\n    \"requiredAccess\": t.opt(\"string\"),\n    \"hasCustomOptions\": t.opt(\"boolean\"),\n    \"columns\": t.opt(\"ColumnsToMap\"),\n});\nexports.InteractionOptions = t.iface([], {\n    \"accessLevel\": \"string\",\n});\nexports.WidgetColumnMap = t.iface([], {\n    [t.indexKey]: t.union(\"string\", t.array(\"string\"), \"null\"),\n});\nexports.CustomSectionAPI = t.iface([], {\n    \"configure\": t.func(\"void\", t.param(\"customOptions\", \"InteractionOptionsRequest\")),\n    \"mappings\": t.func(t.union(\"WidgetColumnMap\", \"null\")),\n});\nconst exportedTypeSuite = {\n    ColumnToMap: exports.ColumnToMap,\n    ColumnsToMap: exports.ColumnsToMap,\n    InteractionOptionsRequest: exports.InteractionOptionsRequest,\n    InteractionOptions: exports.InteractionOptions,\n    WidgetColumnMap: exports.WidgetColumnMap,\n    CustomSectionAPI: exports.CustomSectionAPI,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=CustomSectionAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/CustomSectionAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/CustomSectionAPI.js":
/*!****************************************************!*\
  !*** ./_build/core/app/plugin/CustomSectionAPI.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * API definitions for CustomSection plugins.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=CustomSectionAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/CustomSectionAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/FileParserAPI-ti.js":
/*!****************************************************!*\
  !*** ./_build/core/app/plugin/FileParserAPI-ti.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ParseFileResult = exports.FileSource = exports.ParseOptionSchema = exports.ParseOptions = exports.ParseFileAPI = exports.EditOptionsAPI = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.EditOptionsAPI = t.iface([], {\n    \"getParseOptions\": t.func(\"ParseOptions\", t.param(\"parseOptions\", \"ParseOptions\", true)),\n});\nexports.ParseFileAPI = t.iface([], {\n    \"parseFile\": t.func(\"ParseFileResult\", t.param(\"file\", \"FileSource\"), t.param(\"parseOptions\", \"ParseOptions\", true)),\n});\nexports.ParseOptions = t.iface([], {\n    \"NUM_ROWS\": t.opt(\"number\"),\n    \"SCHEMA\": t.opt(t.array(\"ParseOptionSchema\")),\n});\nexports.ParseOptionSchema = t.iface([], {\n    \"name\": \"string\",\n    \"label\": \"string\",\n    \"type\": \"string\",\n    \"visible\": \"boolean\",\n});\nexports.FileSource = t.iface([], {\n    \"path\": \"string\",\n    \"origName\": \"string\",\n});\nexports.ParseFileResult = t.iface([\"GristTables\"], {\n    \"parseOptions\": \"ParseOptions\",\n});\nconst exportedTypeSuite = {\n    EditOptionsAPI: exports.EditOptionsAPI,\n    ParseFileAPI: exports.ParseFileAPI,\n    ParseOptions: exports.ParseOptions,\n    ParseOptionSchema: exports.ParseOptionSchema,\n    FileSource: exports.FileSource,\n    ParseFileResult: exports.ParseFileResult,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=FileParserAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/FileParserAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/FileParserAPI.js":
/*!*************************************************!*\
  !*** ./_build/core/app/plugin/FileParserAPI.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * API definitions for FileParser plugins.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=FileParserAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/FileParserAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/GristAPI-ti.js":
/*!***********************************************!*\
  !*** ./_build/core/app/plugin/GristAPI-ti.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.GristView = exports.GristDocAPI = exports.GristAPI = exports.ComponentKind = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.ComponentKind = t.union(t.lit(\"safeBrowser\"), t.lit(\"safePython\"), t.lit(\"unsafeNode\"));\nexports.GristAPI = t.iface([], {\n    \"render\": t.func(\"number\", t.param(\"path\", \"string\"), t.param(\"target\", \"RenderTarget\"), t.param(\"options\", \"RenderOptions\", true)),\n    \"dispose\": t.func(\"void\", t.param(\"procId\", \"number\")),\n    \"subscribe\": t.func(\"void\", t.param(\"tableId\", \"string\")),\n    \"unsubscribe\": t.func(\"void\", t.param(\"tableId\", \"string\")),\n});\nexports.GristDocAPI = t.iface([], {\n    \"getDocName\": t.func(\"string\"),\n    \"listTables\": t.func(t.array(\"string\")),\n    \"fetchTable\": t.func(\"any\", t.param(\"tableId\", \"string\")),\n    \"applyUserActions\": t.func(\"any\", t.param(\"actions\", t.array(t.array(\"any\")))),\n});\nexports.GristView = t.iface([], {\n    \"fetchSelectedTable\": t.func(\"any\"),\n    \"fetchSelectedRecord\": t.func(\"any\", t.param(\"rowId\", \"number\")),\n    \"allowSelectBy\": t.func(\"void\"),\n    \"setSelectedRows\": t.func(\"void\", t.param(\"rowIds\", t.array(\"number\"))),\n});\nconst exportedTypeSuite = {\n    ComponentKind: exports.ComponentKind,\n    GristAPI: exports.GristAPI,\n    GristDocAPI: exports.GristDocAPI,\n    GristView: exports.GristView,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=GristAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/GristAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/GristAPI.js":
/*!********************************************!*\
  !*** ./_build/core/app/plugin/GristAPI.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This file defines the interface for the grist api exposed to SafeBrowser plugins. Grist supports\n * various ways to require it to cover various scenarios. If writing the main safeBrowser module\n * (the one referenced by the components.safeBrowser key of the manifest) use\n * `self.importScript('grist');`, if writing a view include the script in the html `<script src=\"grist\"></script>`\n *\n *\n * Example usage (let's assume that Grist let's plugin contributes to a Foo API defined as follow ):\n *\n * interface Foo {\n *   foo(name: string): Promise<string>;\n * }\n *\n * > main.ts:\n * class MyFoo {\n *   public foo(name: string): Promise<string> {\n *     return new Promise<string>( async resolve => {\n *       grist.rpc.onMessage( e => {\n *         resolve(e.data + name);\n *       });\n *       grist.ready();\n *       await grist.api.render('view1.html', 'fullscreen');\n *     });\n *   }\n * }\n * grist.rpc.registerImpl<Foo>('grist', new MyFoo()); // can add 3rd arg with type information\n *\n * > view1.html includes:\n * grist.api.render('static/view2.html', 'fullscreen').then( view => {\n *   grist.rpc.onMessage(e => grist.rpc.postMessageForward(\"main.ts\", e.data));\n * });\n *\n * > view2.html includes:\n * grist.rpc.postMessage('view1.html', 'foo ');\n *\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RPC_GRISTAPI_INTERFACE = void 0;\nexports.RPC_GRISTAPI_INTERFACE = '_grist_api';\n//# sourceMappingURL=GristAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/GristAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/GristTable-ti.js":
/*!*************************************************!*\
  !*** ./_build/core/app/plugin/GristTable-ti.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APIType = exports.GristColumn = exports.GristTables = exports.GristTable = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.GristTable = t.iface([], {\n    \"table_name\": t.union(\"string\", \"null\"),\n    \"column_metadata\": t.array(\"GristColumn\"),\n    \"table_data\": t.array(t.array(\"any\")),\n});\nexports.GristTables = t.iface([], {\n    \"tables\": t.array(\"GristTable\"),\n});\nexports.GristColumn = t.iface([], {\n    \"id\": \"string\",\n    \"type\": \"string\",\n});\nexports.APIType = t.enumtype({\n    \"ImportSourceAPI\": 0,\n    \"ImportProcessorAPI\": 1,\n    \"ParseOptionsAPI\": 2,\n    \"ParseFileAPI\": 3,\n});\nconst exportedTypeSuite = {\n    GristTable: exports.GristTable,\n    GristTables: exports.GristTables,\n    GristColumn: exports.GristColumn,\n    APIType: exports.APIType,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=GristTable-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/GristTable-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/GristTable.js":
/*!**********************************************!*\
  !*** ./_build/core/app/plugin/GristTable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Common definitions for Grist plugin APIs.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.APIType = void 0;\nvar APIType;\n(function (APIType) {\n    APIType[APIType[\"ImportSourceAPI\"] = 0] = \"ImportSourceAPI\";\n    APIType[APIType[\"ImportProcessorAPI\"] = 1] = \"ImportProcessorAPI\";\n    APIType[APIType[\"ParseOptionsAPI\"] = 2] = \"ParseOptionsAPI\";\n    APIType[APIType[\"ParseFileAPI\"] = 3] = \"ParseFileAPI\";\n})(APIType = exports.APIType || (exports.APIType = {}));\n//# sourceMappingURL=GristTable.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/GristTable.js?");

/***/ }),

/***/ "./_build/core/app/plugin/ImportSourceAPI-ti.js":
/*!******************************************************!*\
  !*** ./_build/core/app/plugin/ImportSourceAPI-ti.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ImportSource = exports.URL = exports.FileListItem = exports.FileContent = exports.ImportProcessorAPI = exports.ImportSourceAPI = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.ImportSourceAPI = t.iface([], {\n    \"getImportSource\": t.func(t.union(\"ImportSource\", \"undefined\")),\n});\nexports.ImportProcessorAPI = t.iface([], {\n    \"processImport\": t.func(t.array(\"GristTable\"), t.param(\"source\", \"ImportSource\")),\n});\nexports.FileContent = t.iface([], {\n    \"content\": \"any\",\n    \"name\": \"string\",\n});\nexports.FileListItem = t.iface([], {\n    \"kind\": t.lit(\"fileList\"),\n    \"files\": t.array(\"FileContent\"),\n});\nexports.URL = t.iface([], {\n    \"kind\": t.lit(\"url\"),\n    \"url\": \"string\",\n});\nexports.ImportSource = t.iface([], {\n    \"item\": t.union(\"FileListItem\", \"URL\"),\n    \"options\": t.opt(t.union(\"string\", \"Buffer\")),\n    \"description\": t.opt(\"string\"),\n});\nconst exportedTypeSuite = {\n    ImportSourceAPI: exports.ImportSourceAPI,\n    ImportProcessorAPI: exports.ImportProcessorAPI,\n    FileContent: exports.FileContent,\n    FileListItem: exports.FileListItem,\n    URL: exports.URL,\n    ImportSource: exports.ImportSource,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=ImportSourceAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/ImportSourceAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/ImportSourceAPI.js":
/*!***************************************************!*\
  !*** ./_build/core/app/plugin/ImportSourceAPI.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * API definitions for ImportSource plugins.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=ImportSourceAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/ImportSourceAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/InternalImportSourceAPI-ti.js":
/*!**************************************************************!*\
  !*** ./_build/core/app/plugin/InternalImportSourceAPI-ti.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.InternalImportSourceAPI = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.InternalImportSourceAPI = t.iface([], {\n    \"getImportSource\": t.func(t.union(\"ImportSource\", \"undefined\"), t.param(\"inlineTarget\", \"RenderTarget\")),\n});\nconst exportedTypeSuite = {\n    InternalImportSourceAPI: exports.InternalImportSourceAPI,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=InternalImportSourceAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/InternalImportSourceAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/RenderOptions-ti.js":
/*!****************************************************!*\
  !*** ./_build/core/app/plugin/RenderOptions-ti.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RenderOptions = exports.RenderTarget = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.RenderTarget = t.union(t.lit(\"fullscreen\"), \"number\");\nexports.RenderOptions = t.iface([], {\n    \"height\": t.opt(\"string\"),\n});\nconst exportedTypeSuite = {\n    RenderTarget: exports.RenderTarget,\n    RenderOptions: exports.RenderOptions,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=RenderOptions-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/RenderOptions-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/RenderOptions.js":
/*!*************************************************!*\
  !*** ./_build/core/app/plugin/RenderOptions.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=RenderOptions.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/RenderOptions.js?");

/***/ }),

/***/ "./_build/core/app/plugin/StorageAPI-ti.js":
/*!*************************************************!*\
  !*** ./_build/core/app/plugin/StorageAPI-ti.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Storage = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.Storage = t.iface([], {\n    \"getItem\": t.func(\"any\", t.param(\"key\", \"string\")),\n    \"hasItem\": t.func(\"boolean\", t.param(\"key\", \"string\")),\n    \"setItem\": t.func(\"void\", t.param(\"key\", \"string\"), t.param(\"value\", \"any\")),\n    \"removeItem\": t.func(\"void\", t.param(\"key\", \"string\")),\n    \"clear\": t.func(\"void\"),\n});\nconst exportedTypeSuite = {\n    Storage: exports.Storage,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=StorageAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/StorageAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/StorageAPI.js":
/*!**********************************************!*\
  !*** ./_build/core/app/plugin/StorageAPI.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=StorageAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/StorageAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/TypeCheckers.js":
/*!************************************************!*\
  !*** ./_build/core/app/plugin/TypeCheckers.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkers = exports.WidgetAPITI = exports.StorageAPITI = exports.RenderOptionsTI = exports.InternalImportSourceAPITI = exports.ImportSourceAPITI = exports.GristTableTI = exports.GristAPITI = exports.FileParserAPITI = exports.CustomSectionAPITI = void 0;\nconst ts_interface_checker_1 = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\nconst CustomSectionAPI_ti_1 = __webpack_require__(/*! ./CustomSectionAPI-ti */ \"./_build/core/app/plugin/CustomSectionAPI-ti.js\");\nexports.CustomSectionAPITI = CustomSectionAPI_ti_1.default;\nconst FileParserAPI_ti_1 = __webpack_require__(/*! ./FileParserAPI-ti */ \"./_build/core/app/plugin/FileParserAPI-ti.js\");\nexports.FileParserAPITI = FileParserAPI_ti_1.default;\nconst GristAPI_ti_1 = __webpack_require__(/*! ./GristAPI-ti */ \"./_build/core/app/plugin/GristAPI-ti.js\");\nexports.GristAPITI = GristAPI_ti_1.default;\nconst GristTable_ti_1 = __webpack_require__(/*! ./GristTable-ti */ \"./_build/core/app/plugin/GristTable-ti.js\");\nexports.GristTableTI = GristTable_ti_1.default;\nconst ImportSourceAPI_ti_1 = __webpack_require__(/*! ./ImportSourceAPI-ti */ \"./_build/core/app/plugin/ImportSourceAPI-ti.js\");\nexports.ImportSourceAPITI = ImportSourceAPI_ti_1.default;\nconst InternalImportSourceAPI_ti_1 = __webpack_require__(/*! ./InternalImportSourceAPI-ti */ \"./_build/core/app/plugin/InternalImportSourceAPI-ti.js\");\nexports.InternalImportSourceAPITI = InternalImportSourceAPI_ti_1.default;\nconst RenderOptions_ti_1 = __webpack_require__(/*! ./RenderOptions-ti */ \"./_build/core/app/plugin/RenderOptions-ti.js\");\nexports.RenderOptionsTI = RenderOptions_ti_1.default;\nconst StorageAPI_ti_1 = __webpack_require__(/*! ./StorageAPI-ti */ \"./_build/core/app/plugin/StorageAPI-ti.js\");\nexports.StorageAPITI = StorageAPI_ti_1.default;\nconst WidgetAPI_ti_1 = __webpack_require__(/*! ./WidgetAPI-ti */ \"./_build/core/app/plugin/WidgetAPI-ti.js\");\nexports.WidgetAPITI = WidgetAPI_ti_1.default;\nconst allTypes = [\n    CustomSectionAPI_ti_1.default, FileParserAPI_ti_1.default, GristAPI_ti_1.default, GristTable_ti_1.default, ImportSourceAPI_ti_1.default,\n    InternalImportSourceAPI_ti_1.default, RenderOptions_ti_1.default, StorageAPI_ti_1.default, WidgetAPI_ti_1.default\n];\nfunction checkDuplicates(types) {\n    const seen = new Set();\n    for (const t of types) {\n        for (const key of Object.keys(t)) {\n            if (seen.has(key)) {\n                throw new Error(`TypeCheckers: Duplicate type name ${key}`);\n            }\n            seen.add(key);\n            // Uncomment the line below to generate updated list of included types.\n            // console.log(`'${key}' |`);\n        }\n    }\n}\ncheckDuplicates(allTypes);\n/**\n * We also create and export a global checker object that includes all of the types above.\n */\nexports.checkers = ts_interface_checker_1.createCheckers(...allTypes);\n//# sourceMappingURL=TypeCheckers.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/TypeCheckers.js?");

/***/ }),

/***/ "./_build/core/app/plugin/WidgetAPI-ti.js":
/*!************************************************!*\
  !*** ./_build/core/app/plugin/WidgetAPI-ti.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WidgetAPI = void 0;\n/**\n * This module was automatically generated by `ts-interface-builder`\n */\nconst t = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\n// tslint:disable:object-literal-key-quotes\nexports.WidgetAPI = t.iface([], {\n    \"getOptions\": t.func(t.union(\"object\", \"null\")),\n    \"setOptions\": t.func(\"void\", t.param(\"options\", t.iface([], {\n        [t.indexKey]: \"any\",\n    }))),\n    \"clearOptions\": t.func(\"void\"),\n    \"setOption\": t.func(\"void\", t.param(\"key\", \"string\"), t.param(\"value\", \"any\")),\n    \"getOption\": t.func(\"any\", t.param(\"key\", \"string\")),\n});\nconst exportedTypeSuite = {\n    WidgetAPI: exports.WidgetAPI,\n};\nexports.default = exportedTypeSuite;\n//# sourceMappingURL=WidgetAPI-ti.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/WidgetAPI-ti.js?");

/***/ }),

/***/ "./_build/core/app/plugin/WidgetAPI.js":
/*!*********************************************!*\
  !*** ./_build/core/app/plugin/WidgetAPI.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=WidgetAPI.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/WidgetAPI.js?");

/***/ }),

/***/ "./_build/core/app/plugin/grist-plugin-api.js":
/*!****************************************************!*\
  !*** ./_build/core/app/plugin/grist-plugin-api.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n// Provide a way to access grist for iframe, web worker (which runs the main safeBrowser script) and\n// unsafeNode. WebView should work the same way as iframe, grist is exposed just the same way and\n// necessary api is exposed using preload script. Here we bootstrap from channel capabilities to key\n// parts of the grist API.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ready = exports.addImporter = exports.onOptions = exports.onRecords = exports.onRecord = exports.mapColumnNames = exports.clearOptions = exports.getOptions = exports.setOptions = exports.setOption = exports.getOption = exports.on = exports.docApi = exports.setSelectedRows = exports.allowSelectBy = exports.sectionApi = exports.widgetApi = exports.viewApi = exports.coreDocApi = exports.api = exports.rpc = void 0;\nconst GristAPI_1 = __webpack_require__(/*! ./GristAPI */ \"./_build/core/app/plugin/GristAPI.js\");\nconst objtypes_1 = __webpack_require__(/*! ./objtypes */ \"./_build/core/app/plugin/objtypes.js\");\nconst TypeCheckers_1 = __webpack_require__(/*! ./TypeCheckers */ \"./_build/core/app/plugin/TypeCheckers.js\");\n__exportStar(__webpack_require__(/*! ./TypeCheckers */ \"./_build/core/app/plugin/TypeCheckers.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FileParserAPI */ \"./_build/core/app/plugin/FileParserAPI.js\"), exports);\n__exportStar(__webpack_require__(/*! ./GristAPI */ \"./_build/core/app/plugin/GristAPI.js\"), exports);\n__exportStar(__webpack_require__(/*! ./GristTable */ \"./_build/core/app/plugin/GristTable.js\"), exports);\n__exportStar(__webpack_require__(/*! ./ImportSourceAPI */ \"./_build/core/app/plugin/ImportSourceAPI.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StorageAPI */ \"./_build/core/app/plugin/StorageAPI.js\"), exports);\n__exportStar(__webpack_require__(/*! ./RenderOptions */ \"./_build/core/app/plugin/RenderOptions.js\"), exports);\n__exportStar(__webpack_require__(/*! ./WidgetAPI */ \"./_build/core/app/plugin/WidgetAPI.js\"), exports);\n__exportStar(__webpack_require__(/*! ./CustomSectionAPI */ \"./_build/core/app/plugin/CustomSectionAPI.js\"), exports);\nconst grain_rpc_1 = __webpack_require__(/*! grain-rpc */ \"./node_modules/grain-rpc/dist/lib/index.js\");\nexports.rpc = new grain_rpc_1.Rpc({ logger: createRpcLogger() });\nexports.api = exports.rpc.getStub(GristAPI_1.RPC_GRISTAPI_INTERFACE, TypeCheckers_1.checkers.GristAPI);\nexports.coreDocApi = exports.rpc.getStub('GristDocAPI@grist', TypeCheckers_1.checkers.GristDocAPI);\nexports.viewApi = exports.rpc.getStub('GristView', TypeCheckers_1.checkers.GristView);\nexports.widgetApi = exports.rpc.getStub('WidgetAPI', TypeCheckers_1.checkers.WidgetAPI);\nexports.sectionApi = exports.rpc.getStub('CustomSectionAPI', TypeCheckers_1.checkers.CustomSectionAPI);\nexports.allowSelectBy = exports.viewApi.allowSelectBy;\nexports.setSelectedRows = exports.viewApi.setSelectedRows;\nexports.docApi = Object.assign(Object.assign(Object.assign({}, exports.coreDocApi), exports.viewApi), { \n    // Change fetchSelectedTable() to decode data by default, replacing e.g. ['D', timestamp] with\n    // a moment date. New option `keepEncoded` skips the decoding step.\n    async fetchSelectedTable(options = {}) {\n        const table = await exports.viewApi.fetchSelectedTable();\n        return options.keepEncoded ? table :\n            objtypes_1.mapValues(table, (col) => col.map(objtypes_1.decodeObject));\n    },\n    // Change fetchSelectedRecord() to decode data by default, replacing e.g. ['D', timestamp] with\n    // a moment date. New option `keepEncoded` skips the decoding step.\n    async fetchSelectedRecord(rowId, options = {}) {\n        const rec = await exports.viewApi.fetchSelectedRecord(rowId);\n        return options.keepEncoded ? rec :\n            objtypes_1.mapValues(rec, objtypes_1.decodeObject);\n    } });\nexports.on = exports.rpc.on.bind(exports.rpc);\n// Exposing widgetApi methods in a module scope.\nexports.getOption = exports.widgetApi.getOption.bind(exports.widgetApi);\nexports.setOption = exports.widgetApi.setOption.bind(exports.widgetApi);\nexports.setOptions = exports.widgetApi.setOptions.bind(exports.widgetApi);\nexports.getOptions = exports.widgetApi.getOptions.bind(exports.widgetApi);\nexports.clearOptions = exports.widgetApi.clearOptions.bind(exports.widgetApi);\n// For custom widgets that support custom columns mappings store current configuration\n// in a memory.\n// Actual cached value. Undefined means that widget hasn't asked for configuration yet.\n// Here we are storing serialized configuration instead of actual one, since widget can\n// mutate returned value.\nlet _mappingsCache;\n// Since widget needs to ask for mappings during onRecord and onRecords event, we will reuse\n// current request if available;\nlet _activeRefreshReq = null;\n// Remember columns requested during ready call.\nlet _columnsToMap;\nasync function getMappingsIfChanged(data) {\n    const uninitialized = _mappingsCache === undefined;\n    if (data.mappingsChange || uninitialized) {\n        // If no active request.\n        if (!_activeRefreshReq) {\n            // Request for new mappings.\n            _activeRefreshReq = exports.sectionApi\n                .mappings()\n                // Store it in global variable.\n                .then(mappings => void (_mappingsCache = mappings))\n                // Clear current request variable.\n                .finally(() => _activeRefreshReq = null);\n        }\n        await _activeRefreshReq;\n    }\n    return _mappingsCache ? JSON.parse(JSON.stringify(_mappingsCache)) : null;\n}\n/**\n * Renames columns in the result using columns mapping configuration passed in ready method.\n * Returns null if not all required columns were mapped or not widget doesn't support\n * custom column mapping.\n */\nfunction mapColumnNames(data, options = {\n    columns: _columnsToMap,\n    mappings: _mappingsCache\n}) {\n    // If not column configuration was requested or\n    // table has no rows, return original data.\n    if (!options.columns) {\n        return data;\n    }\n    // If we haven't received columns configuration return null.\n    if (!options.mappings) {\n        return null;\n    }\n    // If we are renaming names for whole table, but it is empty, don't do anything.\n    if (Array.isArray(data) && data.length === 0) {\n        return data;\n    }\n    // Prepare convert function - a function that will take record returned from Grist\n    // and convert it to a new record with mapped field names;\n    // Convert function will consists of several transformations:\n    const transformations = [];\n    // First transformation is for copying id field:\n    transformations.push((from, to) => to.id = from.id);\n    // Helper function to test if a column was configured as optional.\n    function isOptional(col) {\n        var _a, _b;\n        return Boolean(\n        // Columns passed as strings are required.\n        !((_a = options.columns) === null || _a === void 0 ? void 0 : _a.includes(col))\n            && ((_b = options.columns) === null || _b === void 0 ? void 0 : _b.find(c => typeof c === 'object' && (c === null || c === void 0 ? void 0 : c.name) === col && c.optional)));\n    }\n    // For each widget column in mapping.\n    for (const widgetCol in options.mappings) {\n        // Get column from Grist.\n        const gristCol = options.mappings[widgetCol];\n        // Copy column as series (multiple values)\n        if (Array.isArray(gristCol) && gristCol.length) {\n            transformations.push((from, to) => {\n                to[widgetCol] = gristCol.map(col => from[col]);\n            });\n            // Copy column directly under widget column name.\n        }\n        else if (!Array.isArray(gristCol) && gristCol) {\n            transformations.push((from, to) => to[widgetCol] = from[gristCol]);\n        }\n        else if (!isOptional(widgetCol)) {\n            // Column was not configured but was required.\n            return null;\n        }\n    }\n    // Finally assemble function to convert a single record.\n    const convert = (rec) => transformations.reduce((obj, tran) => { tran(rec, obj); return obj; }, {});\n    // Transform all records (or a single one depending on the arguments).\n    return Array.isArray(data) ? data.map(convert) : convert(data);\n}\nexports.mapColumnNames = mapColumnNames;\n// For custom widgets, add a handler that will be called whenever the\n// row with the cursor changes - either by switching to a different row, or\n// by some value within the row potentially changing.  Handler may\n// in the future be called with null if the cursor moves away from\n// any row.\n// TODO: currently this will be called even if the content of a different row\n// changes.\nfunction onRecord(callback) {\n    exports.on('message', async function (msg) {\n        if (!msg.tableId || !msg.rowId) {\n            return;\n        }\n        const rec = await exports.docApi.fetchSelectedRecord(msg.rowId);\n        callback(rec, await getMappingsIfChanged(msg));\n    });\n}\nexports.onRecord = onRecord;\n// For custom widgets, add a handler that will be called whenever the\n// selected records change.  Handler will be called with a list of records.\nfunction onRecords(callback) {\n    exports.on('message', async function (msg) {\n        if (!msg.tableId || !msg.dataChange) {\n            return;\n        }\n        const data = await exports.docApi.fetchSelectedTable();\n        if (!data.id) {\n            return;\n        }\n        const rows = [];\n        for (let i = 0; i < data.id.length; i++) {\n            const row = { id: data.id[i] };\n            for (const key of Object.keys(data)) {\n                row[key] = data[key][i];\n            }\n            rows.push(row);\n        }\n        callback(rows, await getMappingsIfChanged(msg));\n    });\n}\nexports.onRecords = onRecords;\n// For custom widgets, add a handler that will be called whenever the\n// widget options change (and on initial ready message). Handler will be\n// called with an object containing save json options, or null if no options were saved.\n// Second parameter\nfunction onOptions(callback) {\n    exports.on('message', async function (msg) {\n        if (msg.settings) {\n            callback(msg.options || null, msg.settings);\n        }\n    });\n}\nexports.onOptions = onOptions;\n/**\n * Calling `addImporter(...)` adds a safeBrowser importer. It is a short-hand for forwarding calls\n * to an `ImportSourceAPI` implementation registered in the file at `path`. It takes care of\n * creating the stub, registering an implementation that renders the file, forward the call and\n * dispose the view properly. If `mode` is `'inline'` embeds the view in the import modal, otherwise\n * renders fullscreen.\n *\n * Notes: it assumes that file at `path` registers an `ImportSourceAPI` implementation under\n * `name`. Calling `addImporter(...)` from another component than a `safeBrowser` component is not\n * currently supported.\n *\n */\nasync function addImporter(name, path, mode, options) {\n    // checker is omitted for implementation because call was already checked by grist.\n    exports.rpc.registerImpl(name, {\n        async getImportSource(target) {\n            const procId = await exports.api.render(path, mode === 'inline' ? target : 'fullscreen', options);\n            try {\n                // stubName for the interface `name` at forward destination `path`\n                const stubName = `${name}@${path}`;\n                // checker is omitted in stub because call will be checked just after in grist.\n                return await exports.rpc.getStub(stubName).getImportSource();\n            }\n            finally {\n                await exports.api.dispose(procId);\n            }\n        }\n    });\n}\nexports.addImporter = addImporter;\n/**\n * Declare that a component is prepared to receive messages from the outside world.\n * Grist will not attempt to communicate with it until this method is called.\n */\nfunction ready(settings) {\n    if (settings && settings.onEditOptions) {\n        exports.rpc.registerFunc('editOptions', settings.onEditOptions);\n    }\n    exports.rpc.processIncoming();\n    void (async function () {\n        await exports.rpc.sendReadyMessage();\n        if (settings) {\n            const options = Object.assign(Object.assign({}, (settings)), { hasCustomOptions: Boolean(settings.onEditOptions) });\n            delete options.onEditOptions;\n            _columnsToMap = options.columns;\n            await exports.sectionApi.configure(options).catch((err) => console.error(err));\n        }\n    })();\n}\nexports.ready = ready;\nfunction getPluginPath(location) {\n    return location.pathname.replace(/^\\/plugins\\//, '');\n}\nif (typeof window !== 'undefined') {\n    // Window or iframe.\n    const preloadWindow = window;\n    if (preloadWindow.isRunningUnderElectron) {\n        exports.rpc.setSendMessage(msg => preloadWindow.sendToHost(msg));\n        preloadWindow.onGristMessage((data) => exports.rpc.receiveMessage(data));\n    }\n    else {\n        exports.rpc.setSendMessage(msg => window.parent.postMessage(msg, \"*\"));\n        window.onmessage = (e) => exports.rpc.receiveMessage(e.data);\n    }\n    // Allow outer Grist application to trigger printing. This is similar to using\n    // iframe.contentWindow.print(), but that call does not work cross-domain.\n    exports.rpc.registerFunc(\"print\", () => window.print());\n}\nelse if (typeof process === 'undefined') {\n    // Web worker. We can't really bring in the types for WebWorker (available with --lib flag)\n    // without conflicting with a regular window, so use just use `self as any` here.\n    self.onmessage = (e) => exports.rpc.receiveMessage(e.data);\n    exports.rpc.setSendMessage((mssg) => self.postMessage(mssg));\n}\nelse if (typeof process.send !== 'undefined') {\n    // Forked ChildProcess of node or electron.\n    // sendMessage callback returns void 0 because rpc process.send returns a boolean and rpc\n    // expecting void|Promise interprets truthy values as Promise which cause failure.\n    exports.rpc.setSendMessage((data) => { process.send(data); });\n    process.on('message', (data) => exports.rpc.receiveMessage(data));\n    process.on('disconnect', () => { process.exit(0); });\n}\nelse {\n    // Not a recognized environment, perhaps plain nodejs run independently of Grist, or tests\n    // running under mocha. For now, we only provide a dysfunctional implementation. It allows\n    // plugins to call methods like registerFunction() without failing, so that plugin code may be\n    // imported, but the methods don't do anything useful.\n    exports.rpc.setSendMessage((data) => { return; });\n}\nfunction createRpcLogger() {\n    let prefix;\n    if (typeof window !== 'undefined') {\n        prefix = `PLUGIN VIEW ${getPluginPath(window.location)}:`;\n    }\n    else if (typeof process === 'undefined') {\n        prefix = `PLUGIN VIEW ${getPluginPath(self.location)}:`;\n    }\n    else if (typeof process.send !== 'undefined') {\n        prefix = `PLUGIN NODE ${process.env.GRIST_PLUGIN_PATH || \"<unset-plugin-id>\"}:`;\n    }\n    else {\n        return {};\n    }\n    return {\n        info(msg) { console.log(\"%s %s\", prefix, msg); },\n        warn(msg) { console.warn(\"%s %s\", prefix, msg); },\n    };\n}\n//# sourceMappingURL=grist-plugin-api.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/grist-plugin-api.js?");

/***/ }),

/***/ "./_build/core/app/plugin/objtypes.js":
/*!********************************************!*\
  !*** ./_build/core/app/plugin/objtypes.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * Encodes and decodes Grist encoding of values, mirroring similar Python functions in\n * sandbox/grist/objtypes.py.\n */\n// tslint:disable:max-classes-per-file\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapValues = exports.decodeObject = exports.encodeObject = exports.CensoredValue = exports.SkipValue = exports.PendingValue = exports.UnknownValue = exports.RaisedException = exports.ReferenceList = exports.Reference = exports.GristDateTime = exports.GristDate = exports.PENDING_DATA_PLACEHOLDER = void 0;\nconst isPlainObject = __webpack_require__(/*! lodash/isPlainObject */ \"./node_modules/lodash/isPlainObject.js\");\n// The text to show on cells whose values are pending.\nexports.PENDING_DATA_PLACEHOLDER = \"Loading...\";\n/**\n * A GristDate is just a JS Date object whose toString() method returns YYYY-MM-DD.\n */\nclass GristDate extends Date {\n    static fromGristValue(epochSec) {\n        return new GristDate(epochSec * 1000);\n    }\n    toString() {\n        return this.toISOString().slice(0, 10);\n    }\n}\nexports.GristDate = GristDate;\n/**\n * A GristDateTime is a JS Date with an added timezone field. Its toString() returns the date in\n * ISO format. To create a timezone-aware momentjs object, use:\n *\n *    moment(d).tz(d.timezone)\n */\nclass GristDateTime extends Date {\n    static fromGristValue(epochSec, timezone) {\n        return Object.assign(new GristDateTime(epochSec * 1000), { timezone });\n    }\n    toString() { return this.toISOString(); }\n}\nexports.GristDateTime = GristDateTime;\n/**\n * A Reference represents a reference to a row in a table. It is simply a pair of a string tableId\n * and a numeric rowId.\n */\nclass Reference {\n    constructor(tableId, rowId) {\n        this.tableId = tableId;\n        this.rowId = rowId;\n    }\n    toString() {\n        return `${this.tableId}[${this.rowId}]`;\n    }\n}\nexports.Reference = Reference;\n/**\n * A ReferenceList represents a reference to a number of rows in a table. It is simply a pair of a string tableId\n * and a numeric array rowIds.\n */\nclass ReferenceList {\n    constructor(tableId, rowIds) {\n        this.tableId = tableId;\n        this.rowIds = rowIds;\n    }\n    toString() {\n        return `${this.tableId}[[${this.rowIds}]]`;\n    }\n}\nexports.ReferenceList = ReferenceList;\n/**\n * A RaisedException represents a formula error. It includes the exception name, message, and\n * optional details.\n */\nclass RaisedException {\n    constructor(list) {\n        var _a;\n        if (!list.length) {\n            throw new Error(\"RaisedException requires a name as first element\");\n        }\n        list = [...list];\n        this.name = list.shift();\n        this.message = list.shift();\n        this.details = list.shift();\n        this.user_input = (_a = list.shift()) === null || _a === void 0 ? void 0 : _a.u;\n    }\n    /**\n     * This is designed to look somewhat similar to Excel, e.g. #VALUE or #DIV/0!\"\n     */\n    toString() {\n        switch (this.name) {\n            case 'ZeroDivisionError': return '#DIV/0!';\n            case 'UnmarshallableError': return this.details || ('#' + this.name);\n            case 'InvalidTypedValue': return `#Invalid ${this.message}: ${this.details}`;\n        }\n        return '#' + this.name;\n    }\n}\nexports.RaisedException = RaisedException;\n/**\n * An UnknownValue is a fallback for values that we don't handle otherwise, e.g. of a Python\n * formula returned a function object, or a value we fail to decode.\n * It is typically the Python repr() string of the value.\n */\nclass UnknownValue {\n    constructor(value) {\n        this.value = value;\n    }\n    // When encoding an unknown value, get a best-effort string form of it.\n    static safeRepr(value) {\n        try {\n            return String(value);\n        }\n        catch (e) {\n            return `<${typeof value}>`;\n        }\n    }\n    toString() {\n        return String(this.value);\n    }\n}\nexports.UnknownValue = UnknownValue;\n/**\n * A trivial placeholder for a value that's not yet available.\n */\nclass PendingValue {\n    toString() {\n        return exports.PENDING_DATA_PLACEHOLDER;\n    }\n}\nexports.PendingValue = PendingValue;\n/**\n * A trivial placeholder for a value that won't be shown.\n */\nclass SkipValue {\n    toString() {\n        return '...';\n    }\n}\nexports.SkipValue = SkipValue;\n/**\n * A placeholder for a value hidden by access control rules.\n * Depending on the types of the columns involved, copying\n * a censored value and pasting elsewhere will either use\n * CensoredValue.__repr__ (python) or CensoredValue.toString (typescript)\n * so they should match\n */\nclass CensoredValue {\n    toString() {\n        return 'CENSORED';\n    }\n}\nexports.CensoredValue = CensoredValue;\n/**\n * Produces a Grist-encoded version of the value, e.g. turning a Date into ['d', timestamp].\n * Returns ['U', repr(value)] if it fails to encode otherwise.\n *\n * TODO Add tests. This is not yet used for anything.\n */\nfunction encodeObject(value) {\n    try {\n        switch (typeof value) {\n            case 'string':\n            case 'number':\n            case 'boolean':\n                return value;\n        }\n        if (value == null) {\n            return null;\n        }\n        else if (value instanceof Reference) {\n            return [\"R\" /* Reference */, value.tableId, value.rowId];\n        }\n        else if (value instanceof ReferenceList) {\n            return [\"r\" /* ReferenceList */, value.tableId, value.rowIds];\n        }\n        else if (value instanceof Date) {\n            const timestamp = value.valueOf() / 1000;\n            if ('timezone' in value) {\n                return [\"D\" /* DateTime */, timestamp, value.timezone];\n            }\n            else {\n                // TODO Depending on how it's used, may want to return ['d', timestamp] for UTC midnight.\n                return [\"D\" /* DateTime */, timestamp, 'UTC'];\n            }\n        }\n        else if (value instanceof CensoredValue) {\n            return [\"C\" /* Censored */];\n        }\n        else if (value instanceof RaisedException) {\n            return [\"E\" /* Exception */, value.name, value.message, value.details];\n        }\n        else if (Array.isArray(value)) {\n            return [\"L\" /* List */, ...value.map(encodeObject)];\n        }\n        else if (isPlainObject(value)) {\n            return [\"O\" /* Dict */, mapValues(value, encodeObject, { sort: true })];\n        }\n    }\n    catch (e) {\n        // Fall through to return a best-effort representation.\n    }\n    // We either don't know how to convert the value, or failed during the conversion. Instead we\n    // return an \"UnmarshallableValue\" object, with repr() of the value to show to the user.\n    return [\"U\" /* Unmarshallable */, UnknownValue.safeRepr(value)];\n}\nexports.encodeObject = encodeObject;\n/**\n * Given a Grist-encoded value, returns an object represented by it.\n * If the type code is unknown, or construction fails for any reason, returns an UnknownValue.\n */\nfunction decodeObject(value) {\n    if (!Array.isArray(value)) {\n        return value;\n    }\n    const code = value[0];\n    const args = value.slice(1);\n    let err;\n    try {\n        switch (code) {\n            case 'D': return GristDateTime.fromGristValue(args[0], String(args[1]));\n            case 'd': return GristDate.fromGristValue(args[0]);\n            case 'E': return new RaisedException(args);\n            case 'L': return args.map(decodeObject);\n            case 'O': return mapValues(args[0], decodeObject, { sort: true });\n            case 'P': return new PendingValue();\n            case 'r': return new ReferenceList(String(args[0]), args[1]);\n            case 'R': return new Reference(String(args[0]), args[1]);\n            case 'S': return new SkipValue();\n            case 'C': return new CensoredValue();\n            case 'U': return new UnknownValue(args[0]);\n        }\n    }\n    catch (e) {\n        err = e;\n    }\n    // If we can't decode, return an UnknownValue with some attempt to represent what we couldn't\n    // decode as long as some info about the error if any.\n    return new UnknownValue(`${code}(${JSON.stringify(args).slice(1, -1)})` +\n        (err ? `#${err.name}(${err.message})` : ''));\n}\nexports.decodeObject = decodeObject;\n// Like lodash's mapValues, with support for sorting keys, for friendlier output.\nfunction mapValues(sourceObj, mapper, options = {}) {\n    const result = {};\n    const keys = Object.keys(sourceObj);\n    if (options.sort) {\n        keys.sort();\n    }\n    for (const key of keys) {\n        result[key] = mapper(sourceObj[key]);\n    }\n    return result;\n}\nexports.mapValues = mapValues;\n//# sourceMappingURL=objtypes.js.map\n\n//# sourceURL=webpack://grist/./_build/core/app/plugin/objtypes.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nvar base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nvar ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nvar isArray = __webpack_require__(/*! isarray */ \"./node_modules/isarray/index.js\")\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://grist/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/events/events.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/index.js":
/*!**************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nfunction __export(m) {\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__export(__webpack_require__(/*! ./message */ \"./node_modules/grain-rpc/dist/lib/message.js\"));\n__export(__webpack_require__(/*! ./rpc */ \"./node_modules/grain-rpc/dist/lib/rpc.js\"));\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/index.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/message.js":
/*!****************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/message.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/**\n * This defines the message types sent over an RpcChannel.\n *\n * WARNING: Any changes to these must be backward-compatible, since Rpc may be used across\n * different versions of this library. Specifically, enums must not be renumbered, fields renamed,\n * or their types changed. Really, the only reasonable enhancement is adding a new optional field.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar MsgType;\n(function (MsgType) {\n    // Warning: Do NOT renumber enums (see warning above).\n    MsgType[MsgType[\"RpcCall\"] = 1] = \"RpcCall\";\n    MsgType[MsgType[\"RpcRespData\"] = 2] = \"RpcRespData\";\n    MsgType[MsgType[\"RpcRespErr\"] = 3] = \"RpcRespErr\";\n    MsgType[MsgType[\"Custom\"] = 4] = \"Custom\";\n    MsgType[MsgType[\"Ready\"] = 5] = \"Ready\";\n})(MsgType = exports.MsgType || (exports.MsgType = {}));\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/message.js?");

/***/ }),

/***/ "./node_modules/grain-rpc/dist/lib/rpc.js":
/*!************************************************!*\
  !*** ./node_modules/grain-rpc/dist/lib/rpc.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n/**\n * Rpc implements an remote-procedure-call interface on top of a simple messaging interface.\n *\n * The user must provide the messaging between two endpoints, and in return gets the ability to\n * register interfaces or functions at either endpoint, and call them from the other side. For\n * messaging, the user must supply a sendMessage() function to send messages to the other side,\n * and must call rpc.receiveMessage(msg) whenever a message is received.\n *\n * E.g.\n *    rpc.registerImpl<MyInterface>(\"some-name\", new MyInterfaceImpl(), descMyInterfaceImpl);\n *    rpc.getStub<MyInterface>(\"some-name\", descMyInterfaceImpl)\n *          => returns a stub implemeting MyInterface\n *\n * Calls to the generated stub get turned into messages across the channel, and then call to the\n * implementation object registered on the other side. Both return values and exceptions get\n * passed back over the channel, and cause the promise from the stub to be resolved or rejected.\n *\n * Note that the stub interface returns Promises for all methods.\n *\n * Rpc library supports ts-interface-checker descriptors for the interfaces, to allow validation.\n * You may skip it by passing in `rpc.unchecked` where a descriptor is expected; it will skip\n * checks and you will not get descriptive errors.\n *\n * The string name used to register and use an implementation allows for the same Rpc object to be\n * used to expose multiple interfaces, or different implementations of the same interface.\n *\n * Messaging\n * ---------\n * Rpc also supports a messaging interface, with postMessage() to send arbitrary messages, and an\n * EventEmitter interface for \"message\" events to receive them, e.g. on(\"message\", ...). So if you\n * need to multiplex non-Rpc messages over the same channel, Rpc class does it for you.\n *\n * Cleanup\n * -------\n * If the channel is closed or had an error, and will no longer be used, the user of Rpc must\n * call rpc.close() to reject any calls waiting for an answer.\n *\n * If a particular stub for a remote API is no longer needed, user may call rpc.discardStub(stub)\n * to reject any pending calls made to that stub.\n *\n * Timeouts\n * --------\n * TODO (Not yet implementd.)\n * You may call rpc.setTimeout(ms) or rpc.setStubTimeout(stub, ms) to set a call timeout for all\n * stubs or for a particular one. If a response to a call does not arrive within the timeout, the\n * call gets rejected, and the rejection Error will have a \"code\" property set to \"TIMEOUT\".\n *\n * Forwarding\n * ----------\n * Rpc.registerForwarder() along with methods with \"-Forward\" suffix allow one Rpc object to forward\n * calls and messages to another Rpc object. The intended usage is when Rpc connects A to B, and B\n * to C. Then B can use registerForwarder to expose A's interfaces to C (or C's to A) without having\n * to know what exactly they are. A default forwarder can be registered using the '*' name.\n *\n *\n * Instead of using getStubForward and callRemoteFuncForward, the forwarder name can be\n * appended to the interface name as \"interfaceName@forwarderName\" and the regular\n * getStub and callRemoteFunc methods can be used.  For example:\n *   getStub(\"iface@forwarder\")\n * is the same as:\n *   getStubForward(\"forwarder\", \"iface\")\n *\n *\n * E.g. with A.registerImpl(\"A-name\", ...) and B.registerForwarder(\"b2a\", A), we may now call\n * C.getStubForward(\"b2a\", \"A-name\") to get a stub that will forward calls to A, as well as\n * C.postMessageForward(\"b2a\", msg) to have the message received by A.\n *\n * TODO We may want to support progress callbacks, perhaps by supporting arbitrary callbacks as\n * parameters. (Could be implemented by allowing \"meth\" to be [reqId, paramPath]) It would be nice\n * to allow the channel to report progress too, e.g. to report progress of uploading large files.\n *\n * TODO Sending of large files should probably be a separate feature, to allow for channel\n * implementations to stream them.\n */\nconst events_1 = __webpack_require__(/*! events */ \"./node_modules/events/events.js\");\nconst tic = __webpack_require__(/*! ts-interface-checker */ \"./node_modules/ts-interface-checker/dist/index.js\");\nconst message_1 = __webpack_require__(/*! ./message */ \"./node_modules/grain-rpc/dist/lib/message.js\");\nconst plainCall = (callFunc) => callFunc();\nclass Rpc extends events_1.EventEmitter {\n    /**\n     * To use Rpc, you must provide a sendMessage function that sends a message to the other side;\n     * it may be given in the constructor, or later with setSendMessage. You must also call\n     * receiveMessage() for every message received from the other side.\n     */\n    constructor(options = {}) {\n        super();\n        // Note the invariant: _inactiveSendQueue == null iff (_sendMessageCB != null && !_waitForReadyMessage)\n        this._sendMessageCB = null;\n        this._inactiveRecvQueue = null; // queue of received message\n        this._inactiveSendQueue = null; // queue of messages to be sent\n        this._waitForReadyMessage = false;\n        this._implMap = new Map();\n        this._forwarders = new Map();\n        this._pendingCalls = new Map();\n        this._nextRequestId = 1;\n        const { logger = console, sendMessage = null, callWrapper = plainCall } = options;\n        this._logger = logger;\n        this._callWrapper = callWrapper;\n        this.setSendMessage(sendMessage);\n    }\n    /**\n     * To use Rpc, call this for every message received from the other side of the channel.\n     */\n    receiveMessage(msg) {\n        if (this._inactiveRecvQueue) {\n            this._inactiveRecvQueue.push(msg);\n        }\n        else {\n            this._dispatch(msg);\n        }\n    }\n    /**\n     * If you've set up calls to receiveMessage(), but need time to call registerImpl() before\n     * processing new messages, you may use queueIncoming(), make the registerImpl() calls,\n     * and then call processIncoming() to handle queued messages and resume normal processing.\n     */\n    queueIncoming() {\n        if (!this._inactiveRecvQueue) {\n            this._inactiveRecvQueue = [];\n        }\n    }\n    /**\n     * Process received messages queued since queueIncoming, and resume normal processing of\n     * received messages.\n     */\n    processIncoming() {\n        if (this._inactiveRecvQueue) {\n            processQueue(this._inactiveRecvQueue, this._dispatch.bind(this));\n            this._inactiveRecvQueue = null;\n        }\n    }\n    /**\n     * Set the callback to send messages. If set to null, sent messages will be queued. If you\n     * disconnect and want for sent messages to throw, set a callback that throws.\n     */\n    setSendMessage(sendMessage) {\n        this._sendMessageCB = sendMessage;\n        if (this._sendMessageCB) {\n            this._processOutgoing();\n        }\n        else {\n            this._queueOutgoing();\n        }\n    }\n    /**\n     * If your peer may not be listening yet to your messages, you may call this to queue outgoing\n     * messages until receiving a \"ready\" message from the peer. I.e. one peer may call\n     * queueOutgoingUntilReadyMessage() while the other calls sendReadyMessage().\n     */\n    queueOutgoingUntilReadyMessage() {\n        this._waitForReadyMessage = true;\n        this._queueOutgoing();\n    }\n    /**\n     * If your peer is using queueOutgoingUntilReadyMessage(), you should let it know that you are\n     * ready using sendReadyMessage() as soon as you've set up the processing of received messages.\n     * Note that at most one peer may use queueOutgoingUntilReadyMessage(), or they will deadlock.\n     */\n    sendReadyMessage() {\n        return this._sendMessage({ mtype: message_1.MsgType.Ready });\n    }\n    /**\n     * Messaging interface: send data to the other side, to be emitted there as a \"message\" event.\n     */\n    postMessage(data) { return this.postMessageForward(\"\", data); }\n    postMessageForward(fwdDest, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const msg = { mtype: message_1.MsgType.Custom, data };\n            if (fwdDest) {\n                msg.mdest = fwdDest;\n            }\n            yield this._sendMessage(msg);\n        });\n    }\n    registerImpl(name, impl, checker) {\n        if (this._implMap.has(name)) {\n            throw new Error(`Rpc.registerImpl has already been called for ${name}`);\n        }\n        const invokeImpl = (call) => impl[call.meth](...call.args);\n        if (!checker) {\n            this._implMap.set(name, { name, invokeImpl, argsCheckers: null });\n        }\n        else {\n            const ttype = checker.getType();\n            if (!(ttype instanceof tic.TIface)) {\n                throw new Error(\"Rpc.registerImpl requires a Checker for an interface\");\n            }\n            const argsCheckers = {};\n            for (const prop of ttype.props) {\n                if (prop.ttype instanceof tic.TFunc) {\n                    argsCheckers[prop.name] = checker.methodArgs(prop.name);\n                }\n            }\n            this._implMap.set(name, { name, invokeImpl, argsCheckers });\n        }\n    }\n    registerForwarder(fwdName, dest, fwdDest = (fwdName === \"*\" ? \"*\" : \"\")) {\n        const passThru = fwdDest === \"*\";\n        this._forwarders.set(fwdName, {\n            name: \"[FWD]\" + fwdName,\n            argsCheckers: null,\n            invokeImpl: (c) => dest.forwardCall(Object.assign({}, c, { mdest: passThru ? c.mdest : fwdDest })),\n            forwardMessage: (msg) => dest.forwardMessage(Object.assign({}, msg, { mdest: passThru ? msg.mdest : fwdDest })),\n        });\n    }\n    unregisterForwarder(fwdName) {\n        this._forwarders.delete(fwdName);\n    }\n    /**\n     * Unregister an implementation, if one was registered with this name.\n     */\n    unregisterImpl(name) {\n        this._implMap.delete(name);\n    }\n    getStub(name, checker) {\n        const parts = this._parseName(name);\n        return this.getStubForward(parts.forwarder, parts.name, checker);\n    }\n    getStubForward(fwdDest, name, checker) {\n        if (!checker) {\n            // TODO Test, then explain how this works.\n            return new Proxy({}, {\n                get: (target, property, receiver) => {\n                    if (property === \"then\") {\n                        // By default, take care not to look \"thenable\", so that the stub can be returned\n                        // as a value of a Promise:\n                        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/resolve\n                        // If user really wants to proxy \"then\", they can write a checker.\n                        return undefined;\n                    }\n                    return (...args) => this._makeCall(name, property, args, anyChecker, fwdDest);\n                },\n            });\n        }\n        else {\n            const ttype = checker.getType();\n            if (!(ttype instanceof tic.TIface)) {\n                throw new Error(\"Rpc.getStub requires a Checker for an interface\");\n            }\n            const api = {};\n            for (const prop of ttype.props) {\n                if (prop.ttype instanceof tic.TFunc) {\n                    const resultChecker = checker.methodResult(prop.name);\n                    api[prop.name] = (...args) => this._makeCall(name, prop.name, args, resultChecker, fwdDest);\n                }\n            }\n            return api;\n        }\n    }\n    /**\n     * Simple way to registers a function under a given name, with no argument checking.\n     */\n    registerFunc(name, impl) {\n        return this.registerImpl(name, { invoke: impl }, checkerAnyFunc);\n    }\n    /**\n     * Unregister a function, if one was registered with this name.\n     */\n    unregisterFunc(name) {\n        return this.unregisterImpl(name);\n    }\n    /**\n     * Call a remote function registered with registerFunc. Does no type checking.\n     */\n    callRemoteFunc(name, ...args) {\n        const parts = this._parseName(name);\n        return this.callRemoteFuncForward(parts.forwarder, parts.name, ...args);\n    }\n    callRemoteFuncForward(fwdDest, name, ...args) {\n        return this._makeCall(name, \"invoke\", args, anyChecker, fwdDest);\n    }\n    forwardCall(c) {\n        return this._makeCall(c.iface, c.meth, c.args, anyChecker, c.mdest || \"\");\n    }\n    forwardMessage(msg) {\n        return this.postMessageForward(msg.mdest || \"\", msg.data);\n    }\n    // Mark outgoing messages for queueing.\n    _queueOutgoing() {\n        if (!this._inactiveSendQueue) {\n            this._inactiveSendQueue = [];\n        }\n    }\n    // If sendMessageCB is set and we are no longer waiting for a ready message, send out any\n    // queued outgoing messages and resume normal sending.\n    _processOutgoing() {\n        if (this._inactiveSendQueue && this._sendMessageCB && !this._waitForReadyMessage) {\n            processQueue(this._inactiveSendQueue, this._sendMessageOrReject.bind(this, this._sendMessageCB));\n            this._inactiveSendQueue = null;\n        }\n    }\n    _sendMessage(msg) {\n        if (this._inactiveSendQueue) {\n            this._inactiveSendQueue.push(msg);\n        }\n        else {\n            return this._sendMessageOrReject(this._sendMessageCB, msg);\n        }\n    }\n    // This helper calls calls sendMessage(msg), and if that call fails, rejects the call\n    // represented by msg (when it's of type RpcCall).\n    _sendMessageOrReject(sendMessage, msg) {\n        if (this._logger.info) {\n            const desc = (msg.mtype === message_1.MsgType.RpcCall) ? \": \" + this._callDesc(msg) : \"\";\n            this._logger.info(`Rpc sending ${message_1.MsgType[msg.mtype]}${desc}`);\n        }\n        return catchMaybePromise(() => sendMessage(msg), (err) => this._sendReject(msg, err));\n    }\n    // Rejects a RpcCall due to the given send error; this helper always re-throws.\n    _sendReject(msg, err) {\n        const newErr = new ErrorWithCode(\"RPC_SEND_FAILED\", `Send failed: ${err.message}`);\n        if (msg.mtype === message_1.MsgType.RpcCall && msg.reqId !== undefined) {\n            const callObj = this._pendingCalls.get(msg.reqId);\n            if (callObj) {\n                this._pendingCalls.delete(msg.reqId);\n                callObj.reject(newErr);\n            }\n        }\n        this.emit(\"error\", newErr);\n        throw newErr;\n    }\n    _makeCallRaw(iface, meth, args, resultChecker, fwdDest) {\n        return new Promise((resolve, reject) => {\n            const reqId = this._nextRequestId++;\n            const callObj = { reqId, iface, meth, resolve, reject, resultChecker };\n            this._pendingCalls.set(reqId, callObj);\n            // Send the Call message. If the sending fails, reject the _makeCall promise. If it\n            // succeeds, we save {resolve,reject} to resolve _makeCall when we get back a response.\n            this._info(callObj, \"RPC_CALLING\");\n            const msg = { mtype: message_1.MsgType.RpcCall, reqId, iface, meth, args };\n            if (fwdDest) {\n                msg.mdest = fwdDest;\n            }\n            // If _sendMessage fails, reject, allowing it to throw synchronously or not.\n            catchMaybePromise(() => this._sendMessage(msg), reject);\n        });\n    }\n    _makeCall(iface, meth, args, resultChecker, fwdDest) {\n        return this._callWrapper(() => this._makeCallRaw(iface, meth, args, resultChecker, fwdDest));\n    }\n    _dispatch(msg) {\n        switch (msg.mtype) {\n            case message_1.MsgType.RpcCall: {\n                this._onMessageCall(msg);\n                return;\n            }\n            case message_1.MsgType.RpcRespData:\n            case message_1.MsgType.RpcRespErr: {\n                this._onMessageResp(msg);\n                return;\n            }\n            case message_1.MsgType.Custom: {\n                this._onCustomMessage(msg);\n                return;\n            }\n            case message_1.MsgType.Ready: {\n                this._waitForReadyMessage = false;\n                try {\n                    this._processOutgoing();\n                }\n                catch (e) { /* swallowing error, an event 'error' was already emitted */ }\n                return;\n            }\n        }\n    }\n    _onCustomMessage(msg) {\n        if (msg.mdest) {\n            const impl = this._forwarders.get(msg.mdest) || this._forwarders.get(\"*\");\n            if (!impl) {\n                this._warn(null, \"RPC_UNKNOWN_FORWARD_DEST\", `Unknown forward destination: ${msg.mdest}`);\n            }\n            else {\n                impl.forwardMessage(msg);\n            }\n        }\n        else {\n            this.emit(\"message\", msg.data);\n        }\n    }\n    _onMessageCall(call) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let impl;\n            if (call.mdest) {\n                impl = this._forwarders.get(call.mdest) || this._forwarders.get(\"*\");\n                if (!impl) {\n                    return this._failCall(call, \"RPC_UNKNOWN_FORWARD_DEST\", `Unknown forward destination: ${call.mdest}`);\n                }\n            }\n            else {\n                impl = this._implMap.get(call.iface);\n                if (!impl) {\n                    return this._failCall(call, \"RPC_UNKNOWN_INTERFACE\", \"Unknown interface\");\n                }\n            }\n            if (!impl.argsCheckers) {\n                // No call or argument checking.\n            }\n            else {\n                // Check the method name and argument types.\n                if (!impl.argsCheckers.hasOwnProperty(call.meth)) {\n                    return this._failCall(call, \"RPC_UNKNOWN_METHOD\", \"Unknown method\");\n                }\n                const argsChecker = impl.argsCheckers[call.meth];\n                try {\n                    argsChecker.check(call.args);\n                }\n                catch (e) {\n                    return this._failCall(call, \"RPC_INVALID_ARGS\", `Invalid args: ${e.message}`);\n                }\n            }\n            if (call.reqId === undefined) {\n                return this._failCall(call, \"RPC_MISSING_REQID\", \"Missing request id\");\n            }\n            this._info(call, \"RPC_ONCALL\");\n            let result;\n            try {\n                result = yield impl.invokeImpl(call);\n            }\n            catch (e) {\n                return this._failCall(call, e.code, e.message, \"RPC_ONCALL_ERROR\");\n            }\n            this._info(call, \"RPC_ONCALL_OK\");\n            return this._sendResponse(call.reqId, result);\n        });\n    }\n    _failCall(call, code, mesg, reportCode) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._warn(call, reportCode || code, mesg);\n            if (call.reqId !== undefined) {\n                const msg = { mtype: message_1.MsgType.RpcRespErr, reqId: call.reqId, mesg, code };\n                yield this._sendMessage(msg);\n            }\n        });\n    }\n    _sendResponse(reqId, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const msg = { mtype: message_1.MsgType.RpcRespData, reqId, data };\n            yield this._sendMessage(msg);\n        });\n    }\n    _onMessageResp(resp) {\n        const callObj = this._pendingCalls.get(resp.reqId);\n        this._pendingCalls.delete(resp.reqId);\n        if (!callObj) {\n            this._warn(null, \"RPC_UNKNOWN_REQID\", `Response to unknown reqId ${resp.reqId}`);\n            return;\n        }\n        if (resp.mtype === message_1.MsgType.RpcRespErr) {\n            this._info(callObj, \"RPC_RESULT_ERROR\", resp.mesg);\n            return callObj.reject(new ErrorWithCode(resp.code, resp.mesg));\n        }\n        try {\n            callObj.resultChecker.check(resp.data);\n        }\n        catch (e) {\n            this._warn(callObj, \"RPC_RESULT_INVALID\", e.message);\n            return callObj.reject(new ErrorWithCode(\"RPC_INVALID_RESULT\", `Implementation produced invalid result: ${e.message}`));\n        }\n        this._info(callObj, \"RPC_RESULT_OK\");\n        callObj.resolve(resp.data);\n    }\n    _info(call, code, message) {\n        if (this._logger.info) {\n            const msg = message ? \" \" + message : \"\";\n            this._logger.info(`Rpc for ${this._callDesc(call)}: ${code}${msg}`);\n        }\n    }\n    _warn(call, code, message) {\n        if (this._logger.warn) {\n            const msg = message ? \" \" + message : \"\";\n            this._logger.warn(`Rpc for ${this._callDesc(call)}: ${code}${msg}`);\n        }\n    }\n    _callDesc(call) {\n        if (!call) {\n            return \"?\";\n        }\n        return `${call.iface}.${call.meth}#${call.reqId || \"-\"}`;\n    }\n    _parseName(name) {\n        const idx = name.lastIndexOf(\"@\");\n        if (idx === -1) {\n            return {\n                forwarder: \"\",\n                name,\n            };\n        }\n        return {\n            name: name.substr(0, idx),\n            forwarder: name.substr(idx + 1),\n        };\n    }\n}\nexports.Rpc = Rpc;\n/**\n * Interfaces may throw errors that include .code field, and it gets propagated to callers (e.g.\n * \"NOT_AUTHORIZED\"). Its purpose is to be a stable way to distinguish different types of errors.\n * This way the human-friendly error message can be changed without affecting behavior.\n */\nclass ErrorWithCode extends Error {\n    constructor(code, message) {\n        super(message);\n        this.code = code;\n    }\n}\nexports.ErrorWithCode = ErrorWithCode;\nconst IAnyFunc = tic.iface([], {\n    invoke: tic.func(\"any\"),\n});\nconst { IAnyFunc: checkerAnyFunc } = tic.createCheckers({ IAnyFunc });\nconst checkerAnyResult = checkerAnyFunc.methodResult(\"invoke\");\nconst anyChecker = checkerAnyResult;\n/**\n * A little helper that processes message queues when starting an rpc instance.\n */\nfunction processQueue(queue, processFunc) {\n    let i = 0;\n    try {\n        while (i < queue.length) {\n            // i gets read and then incremented before the call, so that if processFunc throws, the\n            // message still gets removed from the queue (to avoid processing it twice).\n            processFunc(queue[i++]);\n        }\n    }\n    finally {\n        queue.splice(0, i);\n    }\n}\n/**\n * Calls callback(), handling the exception both synchronously and not. If callback and handler\n * both return or throw synchronously, then so does this method.\n */\nfunction catchMaybePromise(callback, handler) {\n    try {\n        const p = callback();\n        if (p) {\n            return p.catch(handler);\n        }\n    }\n    catch (err) {\n        return handler(err);\n    }\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/grain-rpc/dist/lib/rpc.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/isarray/index.js":
/*!***************************************!*\
  !*** ./node_modules/isarray/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n\n//# sourceURL=webpack://grist/./node_modules/isarray/index.js?");

/***/ }),

/***/ "./node_modules/lodash/_Symbol.js":
/*!****************************************!*\
  !*** ./node_modules/lodash/_Symbol.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var root = __webpack_require__(/*! ./_root */ \"./node_modules/lodash/_root.js\");\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nmodule.exports = Symbol;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_Symbol.js?");

/***/ }),

/***/ "./node_modules/lodash/_baseGetTag.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_baseGetTag.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\"),\n    getRawTag = __webpack_require__(/*! ./_getRawTag */ \"./node_modules/lodash/_getRawTag.js\"),\n    objectToString = __webpack_require__(/*! ./_objectToString */ \"./node_modules/lodash/_objectToString.js\");\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nmodule.exports = baseGetTag;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_baseGetTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_freeGlobal.js":
/*!********************************************!*\
  !*** ./node_modules/lodash/_freeGlobal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nmodule.exports = freeGlobal;\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_freeGlobal.js?");

/***/ }),

/***/ "./node_modules/lodash/_getPrototype.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/_getPrototype.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var overArg = __webpack_require__(/*! ./_overArg */ \"./node_modules/lodash/_overArg.js\");\n\n/** Built-in value references. */\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\n\nmodule.exports = getPrototype;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_getPrototype.js?");

/***/ }),

/***/ "./node_modules/lodash/_getRawTag.js":
/*!*******************************************!*\
  !*** ./node_modules/lodash/_getRawTag.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var Symbol = __webpack_require__(/*! ./_Symbol */ \"./node_modules/lodash/_Symbol.js\");\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nmodule.exports = getRawTag;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_getRawTag.js?");

/***/ }),

/***/ "./node_modules/lodash/_objectToString.js":
/*!************************************************!*\
  !*** ./node_modules/lodash/_objectToString.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nmodule.exports = objectToString;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_objectToString.js?");

/***/ }),

/***/ "./node_modules/lodash/_overArg.js":
/*!*****************************************!*\
  !*** ./node_modules/lodash/_overArg.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Creates a unary function that invokes `func` with its argument transformed.\n *\n * @private\n * @param {Function} func The function to wrap.\n * @param {Function} transform The argument transform.\n * @returns {Function} Returns the new function.\n */\nfunction overArg(func, transform) {\n  return function(arg) {\n    return func(transform(arg));\n  };\n}\n\nmodule.exports = overArg;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_overArg.js?");

/***/ }),

/***/ "./node_modules/lodash/_root.js":
/*!**************************************!*\
  !*** ./node_modules/lodash/_root.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var freeGlobal = __webpack_require__(/*! ./_freeGlobal */ \"./node_modules/lodash/_freeGlobal.js\");\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nmodule.exports = root;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/_root.js?");

/***/ }),

/***/ "./node_modules/lodash/isObjectLike.js":
/*!*********************************************!*\
  !*** ./node_modules/lodash/isObjectLike.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nmodule.exports = isObjectLike;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/isObjectLike.js?");

/***/ }),

/***/ "./node_modules/lodash/isPlainObject.js":
/*!**********************************************!*\
  !*** ./node_modules/lodash/isPlainObject.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var baseGetTag = __webpack_require__(/*! ./_baseGetTag */ \"./node_modules/lodash/_baseGetTag.js\"),\n    getPrototype = __webpack_require__(/*! ./_getPrototype */ \"./node_modules/lodash/_getPrototype.js\"),\n    isObjectLike = __webpack_require__(/*! ./isObjectLike */ \"./node_modules/lodash/isObjectLike.js\");\n\n/** `Object#toString` result references. */\nvar objectTag = '[object Object]';\n\n/** Used for built-in method references. */\nvar funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/** Used to infer the `Object` constructor. */\nvar objectCtorString = funcToString.call(Object);\n\n/**\n * Checks if `value` is a plain object, that is, an object created by the\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\n *\n * @static\n * @memberOf _\n * @since 0.8.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\n * @example\n *\n * function Foo() {\n *   this.a = 1;\n * }\n *\n * _.isPlainObject(new Foo);\n * // => false\n *\n * _.isPlainObject([1, 2, 3]);\n * // => false\n *\n * _.isPlainObject({ 'x': 0, 'y': 0 });\n * // => true\n *\n * _.isPlainObject(Object.create(null));\n * // => true\n */\nfunction isPlainObject(value) {\n  if (!isObjectLike(value) || baseGetTag(value) != objectTag) {\n    return false;\n  }\n  var proto = getPrototype(value);\n  if (proto === null) {\n    return true;\n  }\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\n  return typeof Ctor == 'function' && Ctor instanceof Ctor &&\n    funcToString.call(Ctor) == objectCtorString;\n}\n\nmodule.exports = isPlainObject;\n\n\n//# sourceURL=webpack://grist/./node_modules/lodash/isPlainObject.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/index.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Checker = exports.createCheckers = void 0;\nvar types_1 = __webpack_require__(/*! ./types */ \"./node_modules/ts-interface-checker/dist/types.js\");\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ts-interface-checker/dist/util.js\");\n/**\n * Export functions used to define interfaces.\n */\nvar types_2 = __webpack_require__(/*! ./types */ \"./node_modules/ts-interface-checker/dist/types.js\");\nObject.defineProperty(exports, \"TArray\", { enumerable: true, get: function () { return types_2.TArray; } });\nObject.defineProperty(exports, \"TEnumType\", { enumerable: true, get: function () { return types_2.TEnumType; } });\nObject.defineProperty(exports, \"TEnumLiteral\", { enumerable: true, get: function () { return types_2.TEnumLiteral; } });\nObject.defineProperty(exports, \"TFunc\", { enumerable: true, get: function () { return types_2.TFunc; } });\nObject.defineProperty(exports, \"TIface\", { enumerable: true, get: function () { return types_2.TIface; } });\nObject.defineProperty(exports, \"TLiteral\", { enumerable: true, get: function () { return types_2.TLiteral; } });\nObject.defineProperty(exports, \"TName\", { enumerable: true, get: function () { return types_2.TName; } });\nObject.defineProperty(exports, \"TOptional\", { enumerable: true, get: function () { return types_2.TOptional; } });\nObject.defineProperty(exports, \"TParam\", { enumerable: true, get: function () { return types_2.TParam; } });\nObject.defineProperty(exports, \"TParamList\", { enumerable: true, get: function () { return types_2.TParamList; } });\nObject.defineProperty(exports, \"TProp\", { enumerable: true, get: function () { return types_2.TProp; } });\nObject.defineProperty(exports, \"TTuple\", { enumerable: true, get: function () { return types_2.TTuple; } });\nObject.defineProperty(exports, \"TType\", { enumerable: true, get: function () { return types_2.TType; } });\nObject.defineProperty(exports, \"TUnion\", { enumerable: true, get: function () { return types_2.TUnion; } });\nObject.defineProperty(exports, \"TIntersection\", { enumerable: true, get: function () { return types_2.TIntersection; } });\nObject.defineProperty(exports, \"array\", { enumerable: true, get: function () { return types_2.array; } });\nObject.defineProperty(exports, \"enumlit\", { enumerable: true, get: function () { return types_2.enumlit; } });\nObject.defineProperty(exports, \"enumtype\", { enumerable: true, get: function () { return types_2.enumtype; } });\nObject.defineProperty(exports, \"func\", { enumerable: true, get: function () { return types_2.func; } });\nObject.defineProperty(exports, \"iface\", { enumerable: true, get: function () { return types_2.iface; } });\nObject.defineProperty(exports, \"lit\", { enumerable: true, get: function () { return types_2.lit; } });\nObject.defineProperty(exports, \"name\", { enumerable: true, get: function () { return types_2.name; } });\nObject.defineProperty(exports, \"opt\", { enumerable: true, get: function () { return types_2.opt; } });\nObject.defineProperty(exports, \"param\", { enumerable: true, get: function () { return types_2.param; } });\nObject.defineProperty(exports, \"tuple\", { enumerable: true, get: function () { return types_2.tuple; } });\nObject.defineProperty(exports, \"union\", { enumerable: true, get: function () { return types_2.union; } });\nObject.defineProperty(exports, \"intersection\", { enumerable: true, get: function () { return types_2.intersection; } });\nObject.defineProperty(exports, \"rest\", { enumerable: true, get: function () { return types_2.rest; } });\nObject.defineProperty(exports, \"indexKey\", { enumerable: true, get: function () { return types_2.indexKey; } });\nObject.defineProperty(exports, \"BasicType\", { enumerable: true, get: function () { return types_2.BasicType; } });\nvar util_2 = __webpack_require__(/*! ./util */ \"./node_modules/ts-interface-checker/dist/util.js\");\nObject.defineProperty(exports, \"VError\", { enumerable: true, get: function () { return util_2.VError; } });\n/**\n * Takes one of more type suites (e.g. a module generated by `ts-interface-builder`), and combines\n * them into a suite of interface checkers. If a type is used by name, that name should be present\n * among the passed-in type suites.\n *\n * The returned object maps type names to Checker objects.\n */\nfunction createCheckers() {\n    var typeSuite = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSuite[_i] = arguments[_i];\n    }\n    var fullSuite = Object.assign.apply(Object, __spreadArrays([{}, types_1.basicTypes], typeSuite));\n    var checkers = {};\n    for (var _a = 0, typeSuite_1 = typeSuite; _a < typeSuite_1.length; _a++) {\n        var suite_1 = typeSuite_1[_a];\n        for (var _b = 0, _c = Object.keys(suite_1); _b < _c.length; _b++) {\n            var name = _c[_b];\n            checkers[name] = new Checker(fullSuite, suite_1[name]);\n        }\n    }\n    return checkers;\n}\nexports.createCheckers = createCheckers;\n/**\n * Checker implements validation of objects, and also includes accessors to validate method calls.\n * Checkers should be created using `createCheckers()`.\n */\nvar Checker = /** @class */ (function () {\n    // Create checkers by using `createCheckers()` function.\n    function Checker(suite, ttype, _path) {\n        if (_path === void 0) { _path = 'value'; }\n        this.suite = suite;\n        this.ttype = ttype;\n        this._path = _path;\n        this.props = new Map();\n        if (ttype instanceof types_1.TIface) {\n            for (var _i = 0, _a = ttype.props; _i < _a.length; _i++) {\n                var p = _a[_i];\n                this.props.set(p.name, p.ttype);\n            }\n        }\n        this.checkerPlain = this.ttype.getChecker(suite, false);\n        this.checkerStrict = this.ttype.getChecker(suite, true);\n    }\n    /**\n     * Set the path to report in errors, instead of the default \"value\". (E.g. if the Checker is for\n     * a \"person\" interface, set path to \"person\" to report e.g. \"person.name is not a string\".)\n     */\n    Checker.prototype.setReportedPath = function (path) {\n        this._path = path;\n    };\n    /**\n     * Check that the given value satisfies this checker's type, or throw Error.\n     */\n    Checker.prototype.check = function (value) { return this._doCheck(this.checkerPlain, value); };\n    /**\n     * A fast check for whether or not the given value satisfies this Checker's type. This returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.test = function (value) {\n        return this.checkerPlain(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns a non-empty array of error objects describing the errors if the given value does not satisfy this\n     * Checker's type, or null if it does.\n     */\n    Checker.prototype.validate = function (value) {\n        return this._doValidate(this.checkerPlain, value);\n    };\n    /**\n     * Check that the given value satisfies this checker's type strictly. This checks that objects\n     * and tuples have no extra members. Note that this prevents backward compatibility, so usually\n     * a plain check() is more appropriate.\n     */\n    Checker.prototype.strictCheck = function (value) { return this._doCheck(this.checkerStrict, value); };\n    /**\n     * A fast strict check for whether or not the given value satisfies this Checker's type. Returns\n     * true or false, does not produce an error message, and is fast both on success and on failure.\n     */\n    Checker.prototype.strictTest = function (value) {\n        return this.checkerStrict(value, new util_1.NoopContext());\n    };\n    /**\n     * Returns a non-empty array of error objects describing the errors if the given value does not satisfy this\n     * Checker's type strictly, or null if it does.\n     */\n    Checker.prototype.strictValidate = function (value) {\n        return this._doValidate(this.checkerStrict, value);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the type required for the given\n     * property of this interface.\n     */\n    Checker.prototype.getProp = function (prop) {\n        var ttype = this.props.get(prop);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + prop);\n        }\n        return new Checker(this.suite, ttype, this._path + \".\" + prop);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the argument-list required to call\n     * the given method of this interface. E.g. if this Checker is for the interface:\n     *    interface Foo {\n     *      find(s: string, pos?: number): number;\n     *    }\n     * Then methodArgs(\"find\").check(...) will succeed for [\"foo\"] and [\"foo\", 3], but not for [17].\n     */\n    Checker.prototype.methodArgs = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.paramList);\n    };\n    /**\n     * If this checker is for an interface, returns a Checker for the return value of the given\n     * method of this interface.\n     */\n    Checker.prototype.methodResult = function (methodName) {\n        var tfunc = this._getMethod(methodName);\n        return new Checker(this.suite, tfunc.result);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its argument-list.\n     */\n    Checker.prototype.getArgs = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getArgs() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.paramList);\n    };\n    /**\n     * If this checker is for a function, returns a Checker for its result.\n     */\n    Checker.prototype.getResult = function () {\n        if (!(this.ttype instanceof types_1.TFunc)) {\n            throw new Error(\"getResult() applied to non-function\");\n        }\n        return new Checker(this.suite, this.ttype.result);\n    };\n    /**\n     * Return the type for which this is a checker.\n     */\n    Checker.prototype.getType = function () {\n        return this.ttype;\n    };\n    /**\n     * Actual implementation of check() and strictCheck().\n     */\n    Checker.prototype._doCheck = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (!checkerFunc(value, noopCtx)) {\n            var detailCtx = new util_1.DetailContext();\n            checkerFunc(value, detailCtx);\n            throw detailCtx.getError(this._path);\n        }\n    };\n    Checker.prototype._doValidate = function (checkerFunc, value) {\n        var noopCtx = new util_1.NoopContext();\n        if (checkerFunc(value, noopCtx)) {\n            return null;\n        }\n        var detailCtx = new util_1.DetailContext();\n        checkerFunc(value, detailCtx);\n        return detailCtx.getErrorDetails(this._path);\n    };\n    Checker.prototype._getMethod = function (methodName) {\n        var ttype = this.props.get(methodName);\n        if (!ttype) {\n            throw new Error(\"Type has no property \" + methodName);\n        }\n        if (!(ttype instanceof types_1.TFunc)) {\n            throw new Error(\"Property \" + methodName + \" is not a method\");\n        }\n        return ttype;\n    };\n    return Checker;\n}());\nexports.Checker = Checker;\n\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/index.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/types.js":
/*!*********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/types.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(Buffer) {\n/**\n * This module defines nodes used to define types and validations for objects and interfaces.\n */\n// tslint:disable:no-shadowed-variable prefer-for-of\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.basicTypes = exports.BasicType = exports.TParamList = exports.TParam = exports.param = exports.TFunc = exports.func = exports.TProp = exports.TOptional = exports.opt = exports.TIface = exports.iface = exports.indexKey = exports.TEnumLiteral = exports.enumlit = exports.TEnumType = exports.enumtype = exports.TIntersection = exports.intersection = exports.TUnion = exports.union = exports.TTuple = exports.tuple = exports.RestType = exports.rest = exports.TArray = exports.array = exports.TLiteral = exports.lit = exports.TName = exports.name = exports.TType = void 0;\nvar util_1 = __webpack_require__(/*! ./util */ \"./node_modules/ts-interface-checker/dist/util.js\");\n/** Node that represents a type. */\nvar TType = /** @class */ (function () {\n    function TType() {\n    }\n    return TType;\n}());\nexports.TType = TType;\n/** Parses a type spec into a TType node. */\nfunction parseSpec(typeSpec) {\n    return typeof typeSpec === \"string\" ? name(typeSpec) : typeSpec;\n}\nfunction getNamedType(suite, name) {\n    var ttype = suite[name];\n    if (!ttype) {\n        throw new Error(\"Unknown type \" + name);\n    }\n    return ttype;\n}\n/**\n * Defines a type name, either built-in, or defined in this suite. It can typically be included in\n * the specs as just a plain string.\n */\nfunction name(value) { return new TName(value); }\nexports.name = name;\nvar TName = /** @class */ (function (_super) {\n    __extends(TName, _super);\n    function TName(name) {\n        var _this = _super.call(this) || this;\n        _this.name = name;\n        _this._failMsg = \"is not a \" + name;\n        return _this;\n    }\n    TName.prototype.getChecker = function (suite, strict, allowedProps) {\n        // Using names, we can reference a type recursively in its own definition. To avoid an\n        // infinite recursion in getChecker() calls, we cache and reuse the checker that's being built\n        // when it references its own TName node. Note that it's important to reuse the result only\n        // when getChecker() is called with the same arguments, but that's already guaranteed because\n        // we are caching only for the current call and only for the same TName object (not another\n        // instance of name() call for the same name).\n        //\n        // Note also that this is about handling recursive types; it does NOT help validating data\n        // with circular references.\n        var checkerFunc = this._checkerBeingBuilt;\n        if (!checkerFunc) {\n            this._checkerBeingBuilt = function (value, ctx) { return checkerFunc(value, ctx); };\n            try {\n                checkerFunc = this._getChecker(suite, strict, allowedProps);\n            }\n            finally {\n                this._checkerBeingBuilt = undefined;\n            }\n        }\n        return checkerFunc;\n    };\n    TName.prototype._getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.name);\n        var checker = ttype.getChecker(suite, strict, allowedProps);\n        if (ttype instanceof BasicType || ttype instanceof TName) {\n            return checker;\n        }\n        // For complex types, add an additional \"is not a <Type>\" message on failure.\n        return function (value, ctx) { return checker(value, ctx) ? true : ctx.fail(null, _this._failMsg, 0); };\n    };\n    return TName;\n}(TType));\nexports.TName = TName;\n/**\n * Defines a literal value, e.g. lit('hello') or lit(123).\n */\nfunction lit(value) { return new TLiteral(value); }\nexports.lit = lit;\nvar TLiteral = /** @class */ (function (_super) {\n    __extends(TLiteral, _super);\n    function TLiteral(value) {\n        var _this = _super.call(this) || this;\n        _this.value = value;\n        _this.name = JSON.stringify(value);\n        _this._failMsg = \"is not \" + _this.name;\n        return _this;\n    }\n    TLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return (value === _this.value) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TLiteral;\n}(TType));\nexports.TLiteral = TLiteral;\n/**\n * Defines an array type, e.g. array('number').\n */\nfunction array(typeSpec) { return new TArray(parseSpec(typeSpec)); }\nexports.array = array;\nvar TArray = /** @class */ (function (_super) {\n    __extends(TArray, _super);\n    function TArray(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        var elementTypeName = getTypeName(ttype);\n        if (elementTypeName) {\n            _this.name = elementTypeName + \"[]\";\n        }\n        return _this;\n    }\n    TArray.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < value.length; i++) {\n                var ok = itemChecker(value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return TArray;\n}(TType));\nexports.TArray = TArray;\n/**\n * Defines a rest type, e.g. tuple('string', rest(array('number'))).\n */\nfunction rest(typeSpec) {\n    return new RestType(typeSpec);\n}\nexports.rest = rest;\nvar RestType = /** @class */ (function (_super) {\n    __extends(RestType, _super);\n    function RestType(typeSpec) {\n        var _this = _super.call(this) || this;\n        _this.typeSpec = typeSpec;\n        return _this;\n    }\n    RestType.prototype.setStart = function (start) {\n        this._start = start;\n    };\n    RestType.prototype.getChecker = function (suite, strict) {\n        var arrType = typeof this.typeSpec === \"string\" ? getNamedType(suite, this.typeSpec) : this.typeSpec;\n        if (!(arrType instanceof TArray)) {\n            throw new Error(\"Rest type must be an array\");\n        }\n        var itemChecker = arrType.ttype.getChecker(suite, strict);\n        var start = this._start;\n        return function (value, ctx) {\n            for (var i = start; i < value.length; i++) {\n                if (!itemChecker(value[i], ctx)) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n    };\n    return RestType;\n}(TType));\nexports.RestType = RestType;\n/**\n * Defines a tuple type, e.g. tuple('string', 'number').\n */\nfunction tuple() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TTuple(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.tuple = tuple;\nvar TTuple = /** @class */ (function (_super) {\n    __extends(TTuple, _super);\n    function TTuple(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var last = ttypes[ttypes.length - 1];\n        if (last instanceof RestType) {\n            ttypes.pop();\n            _this._restType = last;\n            _this._restType.setStart(ttypes.length);\n        }\n        return _this;\n    }\n    TTuple.prototype.getChecker = function (suite, strict) {\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict); });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value[i], ctx);\n                if (!ok) {\n                    return ctx.fail(i, null, 1);\n                }\n            }\n            return true;\n        };\n        if (this._restType) {\n            var restChecker_1 = this._restType.getChecker(suite, strict);\n            return function (value, ctx) {\n                return checker(value, ctx) && restChecker_1(value, ctx);\n            };\n        }\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TTuple;\n}(TType));\nexports.TTuple = TTuple;\n/**\n * Defines a union type, e.g. union('number', 'null').\n */\nfunction union() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TUnion(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.union = union;\nvar TUnion = /** @class */ (function (_super) {\n    __extends(TUnion, _super);\n    function TUnion(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        var names = ttypes.map(getTypeName)\n            .filter(function (n) { return n; });\n        var otherTypes = ttypes.length - names.length;\n        if (names.length) {\n            if (otherTypes > 0) {\n                names.push(otherTypes + \" more\");\n            }\n            _this._failMsg = \"is none of \" + names.join(\", \");\n        }\n        else {\n            _this._failMsg = \"is none of \" + otherTypes + \" types\";\n        }\n        return _this;\n    }\n    TUnion.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            var ur = ctx.unionResolver();\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var ok = itemCheckers[i](value, ur.createContext());\n                if (ok) {\n                    return true;\n                }\n            }\n            ctx.resolveUnion(ur);\n            return ctx.fail(null, _this._failMsg, 0);\n        };\n    };\n    return TUnion;\n}(TType));\nexports.TUnion = TUnion;\n/**\n * Defines an intersection type, e.g. intersection('number', 'null').\n */\nfunction intersection() {\n    var typeSpec = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        typeSpec[_i] = arguments[_i];\n    }\n    return new TIntersection(typeSpec.map(function (t) { return parseSpec(t); }));\n}\nexports.intersection = intersection;\nvar TIntersection = /** @class */ (function (_super) {\n    __extends(TIntersection, _super);\n    function TIntersection(ttypes) {\n        var _this = _super.call(this) || this;\n        _this.ttypes = ttypes;\n        return _this;\n    }\n    TIntersection.prototype.getChecker = function (suite, strict, allowedProps) {\n        if (allowedProps === void 0) { allowedProps = new Set(); }\n        var itemCheckers = this.ttypes.map(function (t) { return t.getChecker(suite, strict, allowedProps); });\n        return function (value, ctx) {\n            return itemCheckers.every(function (checker) {\n                checker(value, ctx.fork());\n                return ctx.completeFork();\n            }) && !ctx.failed();\n        };\n    };\n    return TIntersection;\n}(TType));\nexports.TIntersection = TIntersection;\n/**\n * Defines an enum type, e.g. enum({'A': 1, 'B': 2}).\n */\nfunction enumtype(values) {\n    return new TEnumType(values);\n}\nexports.enumtype = enumtype;\nvar TEnumType = /** @class */ (function (_super) {\n    __extends(TEnumType, _super);\n    function TEnumType(members) {\n        var _this = _super.call(this) || this;\n        _this.members = members;\n        _this.validValues = new Set();\n        _this._failMsg = \"is not a valid enum value\";\n        _this.validValues = new Set(Object.keys(members).map(function (name) { return members[name]; }));\n        return _this;\n    }\n    TEnumType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) {\n            return (_this.validValues.has(value) ? true : ctx.fail(null, _this._failMsg, 0));\n        };\n    };\n    return TEnumType;\n}(TType));\nexports.TEnumType = TEnumType;\n/**\n * Defines a literal enum value, such as Direction.Up, specified as enumlit(\"Direction\", \"Up\").\n */\nfunction enumlit(name, prop) {\n    return new TEnumLiteral(name, prop);\n}\nexports.enumlit = enumlit;\nvar TEnumLiteral = /** @class */ (function (_super) {\n    __extends(TEnumLiteral, _super);\n    function TEnumLiteral(enumName, prop) {\n        var _this = _super.call(this) || this;\n        _this.enumName = enumName;\n        _this.prop = prop;\n        _this._failMsg = \"is not \" + enumName + \".\" + prop;\n        return _this;\n    }\n    TEnumLiteral.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var ttype = getNamedType(suite, this.enumName);\n        if (!(ttype instanceof TEnumType)) {\n            throw new Error(\"Type \" + this.enumName + \" used in enumlit is not an enum type\");\n        }\n        var val = ttype.members[this.prop];\n        if (!ttype.members.hasOwnProperty(this.prop)) {\n            throw new Error(\"Unknown value \" + this.enumName + \".\" + this.prop + \" used in enumlit\");\n        }\n        return function (value, ctx) { return (value === val) ? true : ctx.fail(null, _this._failMsg, -1); };\n    };\n    return TEnumLiteral;\n}(TType));\nexports.TEnumLiteral = TEnumLiteral;\nfunction makeIfaceProps(props) {\n    return Object.keys(props)\n        .filter(function (name) { return (name !== exports.indexKey); })\n        .map(function (name) { return makeIfaceProp(name, props[name]); });\n}\nfunction makeIfaceProp(name, prop) {\n    return prop instanceof TOptional ?\n        new TProp(name, prop.ttype, true) :\n        new TProp(name, parseSpec(prop), false);\n}\n/**\n * indexKey is a special key that indicates an index signature when used as a key in an interface.\n * E.g. {[key: string]: number} becomes t.iface([], {[t.indexKey]: \"number\"}).\n *\n * We don't distinguish between string- and number-type index signatures, and don't support\n * multiple index signatures.\n */\nexports.indexKey = Symbol();\n/**\n * Defines an interface. The first argument is an array of interfaces that it extends, and the\n * second is an array of properties.\n */\nfunction iface(bases, props) {\n    return new TIface(bases, makeIfaceProps(props), props[exports.indexKey]);\n}\nexports.iface = iface;\nvar TIface = /** @class */ (function (_super) {\n    __extends(TIface, _super);\n    function TIface(bases, props, indexType) {\n        var _this = _super.call(this) || this;\n        _this.bases = bases;\n        _this.props = props;\n        _this.indexType = indexType ? parseSpec(indexType) : undefined;\n        _this.propSet = new Set(props.map(function (p) { return p.name; }));\n        return _this;\n    }\n    TIface.prototype.getChecker = function (suite, strict, allowedProps) {\n        var _this = this;\n        var _a;\n        if (allowedProps === void 0) { allowedProps = new Set(); }\n        this.propSet.forEach(function (prop) { return allowedProps.add(prop); });\n        var baseCheckers = this.bases.map(function (b) { return getNamedType(suite, b).getChecker(suite, strict, allowedProps); });\n        var propCheckers = this.props.map(function (prop) { return prop.ttype.getChecker(suite, strict); });\n        var indexTypeChecker = (_a = this.indexType) === null || _a === void 0 ? void 0 : _a.getChecker(suite, strict);\n        var testCtx = new util_1.NoopContext();\n        // Consider a prop required if it's not optional AND does not allow for undefined as a value.\n        var isPropRequired = this.props.map(function (prop, i) {\n            return !prop.isOpt && !propCheckers[i](undefined, testCtx);\n        });\n        return function (value, ctx) {\n            if (typeof value !== \"object\" || value === null) {\n                return ctx.fail(null, \"is not an object\", 0);\n            }\n            for (var i = 0; i < baseCheckers.length; i++) {\n                baseCheckers[i](value, ctx.fork());\n                if (!ctx.completeFork()) {\n                    return false;\n                }\n            }\n            for (var i = 0; i < propCheckers.length; i++) {\n                var name_1 = _this.props[i].name;\n                var v = value[name_1];\n                if (v === undefined) {\n                    if (isPropRequired[i]) {\n                        ctx.fork().fail(name_1, \"is missing\", 1);\n                        if (!ctx.completeFork()) {\n                            return false;\n                        }\n                    }\n                }\n                else {\n                    var fork = ctx.fork();\n                    var ok = propCheckers[i](v, fork);\n                    if (!ok) {\n                        fork.fail(name_1, null, 1);\n                    }\n                    if (!ctx.completeFork()) {\n                        return false;\n                    }\n                }\n            }\n            if (indexTypeChecker) {\n                for (var prop in value) {\n                    var fork = ctx.fork();\n                    if (!indexTypeChecker(value[prop], fork)) {\n                        fork.fail(prop, null, 1);\n                    }\n                    if (!ctx.completeFork()) {\n                        return false;\n                    }\n                }\n            }\n            else if (strict) {\n                // In strict mode, check also for unknown enumerable properties.\n                for (var prop in value) {\n                    if (!allowedProps.has(prop)) {\n                        ctx.fork().fail(prop, \"is extraneous\", 2);\n                        if (!ctx.completeFork()) {\n                            return false;\n                        }\n                    }\n                }\n            }\n            return !ctx.failed();\n        };\n    };\n    return TIface;\n}(TType));\nexports.TIface = TIface;\n/**\n * Defines an optional property on an interface.\n */\nfunction opt(typeSpec) { return new TOptional(parseSpec(typeSpec)); }\nexports.opt = opt;\nvar TOptional = /** @class */ (function (_super) {\n    __extends(TOptional, _super);\n    function TOptional(ttype) {\n        var _this = _super.call(this) || this;\n        _this.ttype = ttype;\n        return _this;\n    }\n    TOptional.prototype.getChecker = function (suite, strict) {\n        var itemChecker = this.ttype.getChecker(suite, strict);\n        return function (value, ctx) {\n            return value === undefined || itemChecker(value, ctx);\n        };\n    };\n    return TOptional;\n}(TType));\nexports.TOptional = TOptional;\n/**\n * Defines a property in an interface.\n */\nvar TProp = /** @class */ (function () {\n    function TProp(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TProp;\n}());\nexports.TProp = TProp;\n/**\n * Defines a function. The first argument declares the function's return type, the rest declare\n * its parameters.\n */\nfunction func(resultSpec) {\n    var params = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        params[_i - 1] = arguments[_i];\n    }\n    return new TFunc(new TParamList(params), parseSpec(resultSpec));\n}\nexports.func = func;\nvar TFunc = /** @class */ (function (_super) {\n    __extends(TFunc, _super);\n    function TFunc(paramList, result) {\n        var _this = _super.call(this) || this;\n        _this.paramList = paramList;\n        _this.result = result;\n        return _this;\n    }\n    TFunc.prototype.getChecker = function (suite, strict) {\n        return function (value, ctx) {\n            return typeof value === \"function\" ? true : ctx.fail(null, \"is not a function\", 0);\n        };\n    };\n    return TFunc;\n}(TType));\nexports.TFunc = TFunc;\n/**\n * Defines a function parameter.\n */\nfunction param(name, typeSpec, isOpt) {\n    return new TParam(name, parseSpec(typeSpec), Boolean(isOpt));\n}\nexports.param = param;\nvar TParam = /** @class */ (function () {\n    function TParam(name, ttype, isOpt) {\n        this.name = name;\n        this.ttype = ttype;\n        this.isOpt = isOpt;\n    }\n    return TParam;\n}());\nexports.TParam = TParam;\n/**\n * Defines a function parameter list.\n */\nvar TParamList = /** @class */ (function (_super) {\n    __extends(TParamList, _super);\n    function TParamList(params) {\n        var _this = _super.call(this) || this;\n        _this.params = params;\n        return _this;\n    }\n    TParamList.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        var itemCheckers = this.params.map(function (t) { return t.ttype.getChecker(suite, strict); });\n        var testCtx = new util_1.NoopContext();\n        var isParamRequired = this.params.map(function (param, i) {\n            return !param.isOpt && !itemCheckers[i](undefined, testCtx);\n        });\n        var checker = function (value, ctx) {\n            if (!Array.isArray(value)) {\n                return ctx.fail(null, \"is not an array\", 0);\n            }\n            for (var i = 0; i < itemCheckers.length; i++) {\n                var p = _this.params[i];\n                if (value[i] === undefined) {\n                    if (isParamRequired[i]) {\n                        return ctx.fail(p.name, \"is missing\", 1);\n                    }\n                }\n                else {\n                    var ok = itemCheckers[i](value[i], ctx);\n                    if (!ok) {\n                        return ctx.fail(p.name, null, 1);\n                    }\n                }\n            }\n            return true;\n        };\n        if (!strict) {\n            return checker;\n        }\n        return function (value, ctx) {\n            if (!checker(value, ctx)) {\n                return false;\n            }\n            return value.length <= itemCheckers.length ? true :\n                ctx.fail(itemCheckers.length, \"is extraneous\", 2);\n        };\n    };\n    return TParamList;\n}(TType));\nexports.TParamList = TParamList;\n/**\n * Single TType implementation for all basic built-in types.\n */\nvar BasicType = /** @class */ (function (_super) {\n    __extends(BasicType, _super);\n    function BasicType(validator, message) {\n        var _this = _super.call(this) || this;\n        _this.validator = validator;\n        _this.message = message;\n        return _this;\n    }\n    BasicType.prototype.getChecker = function (suite, strict) {\n        var _this = this;\n        return function (value, ctx) { return _this.validator(value) ? true : ctx.fail(null, _this.message, 0); };\n    };\n    return BasicType;\n}(TType));\nexports.BasicType = BasicType;\n/**\n * Defines the suite of basic types.\n */\nexports.basicTypes = {\n    any: new BasicType(function (v) { return true; }, \"is invalid\"),\n    unknown: new BasicType(function (v) { return true; }, \"is invalid\"),\n    number: new BasicType(function (v) { return (typeof v === \"number\"); }, \"is not a number\"),\n    object: new BasicType(function (v) { return (typeof v === \"object\" && v); }, \"is not an object\"),\n    boolean: new BasicType(function (v) { return (typeof v === \"boolean\"); }, \"is not a boolean\"),\n    string: new BasicType(function (v) { return (typeof v === \"string\"); }, \"is not a string\"),\n    symbol: new BasicType(function (v) { return (typeof v === \"symbol\"); }, \"is not a symbol\"),\n    void: new BasicType(function (v) { return (v == null); }, \"is not void\"),\n    undefined: new BasicType(function (v) { return (v === undefined); }, \"is not undefined\"),\n    null: new BasicType(function (v) { return (v === null); }, \"is not null\"),\n    never: new BasicType(function (v) { return false; }, \"is unexpected\"),\n    Date: new BasicType(getIsNativeChecker(\"[object Date]\"), \"is not a Date\"),\n    RegExp: new BasicType(getIsNativeChecker(\"[object RegExp]\"), \"is not a RegExp\"),\n};\n// This approach for checking native object types mirrors that of lodash. Its advantage over\n// `isinstance` is that it can still return true for native objects created in different JS\n// execution environments.\nvar nativeToString = Object.prototype.toString;\nfunction getIsNativeChecker(tag) {\n    return function (v) { return typeof v === \"object\" && v && nativeToString.call(v) === tag; };\n}\nif (typeof Buffer !== \"undefined\") {\n    exports.basicTypes.Buffer = new BasicType(function (v) { return Buffer.isBuffer(v); }, \"is not a Buffer\");\n}\nvar _loop_1 = function (array_1) {\n    exports.basicTypes[array_1.name] = new BasicType(function (v) { return (v instanceof array_1); }, \"is not a \" + array_1.name);\n};\n// Support typed arrays of various flavors\nfor (var _i = 0, _a = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array,\n    Int32Array, Uint32Array, Float32Array, Float64Array, ArrayBuffer]; _i < _a.length; _i++) {\n    var array_1 = _a[_i];\n    _loop_1(array_1);\n}\nfunction getTypeName(t) {\n    if (t instanceof TName || t instanceof TLiteral || t instanceof TArray) {\n        return t.name;\n    }\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../buffer/index.js */ \"./node_modules/buffer/index.js\").Buffer))\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/types.js?");

/***/ }),

/***/ "./node_modules/ts-interface-checker/dist/util.js":
/*!********************************************************!*\
  !*** ./node_modules/ts-interface-checker/dist/util.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __spreadArrays = (this && this.__spreadArrays) || function () {\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n            r[k] = a[j];\n    return r;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DetailContext = exports.NoopContext = exports.VError = void 0;\n/**\n * Error thrown by validation. Besides an informative message, it includes the path to the\n * property which triggered the failure.\n */\nvar VError = /** @class */ (function (_super) {\n    __extends(VError, _super);\n    function VError(path, message) {\n        var _this = _super.call(this, message) || this;\n        _this.path = path;\n        // See https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work for info about this workaround.\n        Object.setPrototypeOf(_this, VError.prototype);\n        return _this;\n    }\n    return VError;\n}(Error));\nexports.VError = VError;\n/**\n * Fast implementation of IContext used for first-pass validation. If that fails, we can validate\n * using DetailContext to collect error messages. That's faster for the common case when messages\n * normally pass validation.\n */\nvar NoopContext = /** @class */ (function () {\n    function NoopContext() {\n        this._failed = false;\n    }\n    NoopContext.prototype.fail = function (relPath, message, score) {\n        this._failed = true;\n        return false;\n    };\n    NoopContext.prototype.fork = function () {\n        return this;\n    };\n    NoopContext.prototype.completeFork = function () {\n        return !this._failed;\n    };\n    NoopContext.prototype.failed = function () {\n        return this._failed;\n    };\n    NoopContext.prototype.unionResolver = function () { return this; };\n    NoopContext.prototype.createContext = function () {\n        this._failed = false;\n        return this;\n    };\n    NoopContext.prototype.resolveUnion = function (ur) { };\n    return NoopContext;\n}());\nexports.NoopContext = NoopContext;\n/**\n * Complete implementation of IContext that collects meaningfull errors.\n */\nvar DetailContext = /** @class */ (function () {\n    function DetailContext() {\n        // Stack of property names and associated messages for reporting helpful error messages.\n        this._propNames = [];\n        this._messages = [];\n        /** Contexts created by fork() which have completed and contain failures */\n        this._failedForks = [];\n        /**\n         * Contains the context returned by fork() which should be checked until\n         * completeFork() is called.\n         * Will be reused for the next fork() if there are no failures.\n         */\n        this._currentFork = null;\n        // Score is used to choose the best union member whose DetailContext to use for reporting.\n        // Higher score means better match (or rather less severe mismatch).\n        this._score = 0;\n    }\n    DetailContext.prototype.fail = function (relPath, message, score) {\n        this._propNames.push(relPath);\n        this._messages.push(message);\n        this._score += score;\n        return false;\n    };\n    DetailContext.prototype.unionResolver = function () {\n        return new DetailUnionResolver();\n    };\n    DetailContext.prototype.resolveUnion = function (unionResolver) {\n        var _a, _b, _c;\n        var u = unionResolver;\n        var best = null;\n        for (var _i = 0, _d = u.contexts; _i < _d.length; _i++) {\n            var ctx = _d[_i];\n            if (!best || ctx._score >= best._score) {\n                best = ctx;\n            }\n        }\n        if (best && best._score > 0) {\n            (_a = this._propNames).push.apply(_a, best._propNames);\n            (_b = this._messages).push.apply(_b, best._messages);\n            (_c = this._failedForks).push.apply(_c, best._failedForks);\n        }\n    };\n    DetailContext.prototype.getError = function (path) {\n        var fullMessage = flatten(this.getErrorDetails(path).map(errorLines))\n            .join(\"\\n\");\n        return new VError(path, fullMessage);\n    };\n    DetailContext.prototype.getErrorDetails = function (path) {\n        var detail = null;\n        var nested;\n        var details = [];\n        // As checkers call fail() and return to their parent checkers,\n        // the deepest failures are recorded first.\n        // Go through failures in reverse to start from the root type\n        for (var i = this._propNames.length - 1; i >= 0; i--) {\n            var p = this._propNames[i];\n            path += (typeof p === \"number\") ? \"[\" + p + \"]\" : (p ? \".\" + p : \"\");\n            var message = this._messages[i];\n            if (!message) {\n                continue;\n            }\n            nested = { path: path, message: message };\n            if (detail) {\n                detail.nested = [nested];\n            }\n            else {\n                // This is the root failure, so it will be returned\n                details.push(nested);\n            }\n            // Move into the deeper error\n            detail = nested;\n        }\n        var forkErrors = flatten(this._failedForks.map(function (fork) { return fork.getErrorDetails(path); }));\n        if (detail) {\n            // don't put an empty array in detail.nested\n            if (forkErrors.length) {\n                // detail is the deepest nested error, so detail.nested is null at this point\n                detail.nested = forkErrors;\n            }\n        }\n        else {\n            // There were no 'plain' failures, only fork failures\n            details = forkErrors;\n        }\n        return details;\n    };\n    DetailContext.prototype.fork = function () {\n        if (this._currentFork == null) {\n            this._currentFork = new DetailContext();\n        }\n        return this._currentFork;\n    };\n    DetailContext.prototype.completeFork = function () {\n        var fork = this._currentFork;\n        if (fork._failed()) {\n            this._failedForks.push(fork);\n            this._currentFork = null;\n            // To preserve old behaviour, use the score of the first failure\n            // Might want to revise this\n            if (this._failedForks.length === 1) {\n                this._score = fork._score;\n            }\n        }\n        return this._failedForks.length < DetailContext.maxForks;\n    };\n    // failed() is the public interface,\n    // it gets monkeypatched to ensure correct usage in checkers.\n    // _failed() may be called internally\n    // in ways which would fail the monkeypatched assertions.\n    DetailContext.prototype.failed = function () {\n        return this._failed();\n    };\n    DetailContext.prototype._failed = function () {\n        return this._propNames.length + this._failedForks.length > 0;\n    };\n    /**\n     * Maximum number of errors recorded at one level for an object,\n     * i.e. the maximum length of Checker.validate() or IErrorDetail.nested.\n     */\n    // If _failedForks has this length then completeFork() should return false\n    // so that the checker stops making more forks.\n    DetailContext.maxForks = 3;\n    return DetailContext;\n}());\nexports.DetailContext = DetailContext;\nvar DetailUnionResolver = /** @class */ (function () {\n    function DetailUnionResolver() {\n        this.contexts = [];\n    }\n    DetailUnionResolver.prototype.createContext = function () {\n        var ctx = new DetailContext();\n        this.contexts.push(ctx);\n        return ctx;\n    };\n    return DetailUnionResolver;\n}());\n/**\n * Returns lines of a message describing `error`.\n * The lines should be newline separated in the final message.\n * Only returns multiple lines if `error` or a descendant\n * has multiple errors in its `.nested` array.\n * Simple paths of nested errors anywhere in the tree\n * are collapsed into a single line until a branch is reached.\n */\nvar errorLines = function (error) {\n    var rootMessage = error.path + \" \" + error.message;\n    var nestedErrors = error.nested || [];\n    var nestedLines = flatten(nestedErrors.map(errorLines));\n    if (nestedErrors.length == 1) {\n        // Single nested errors are collapsed into the first line,\n        // but they may have branches deeper down leading to more lines\n        // which are already indented\n        var first = nestedLines[0], rest = nestedLines.slice(1);\n        return __spreadArrays([\n            rootMessage + \"; \" + first\n        ], rest);\n    }\n    else {\n        // Indent messages from nested errors\n        // or just return [rootMessage] if there are no nested errors\n        return __spreadArrays([\n            rootMessage\n        ], nestedLines.map(function (line) { return \"    \" + line; }));\n    }\n};\n/** Shallow flatten a 2D array into a 1D array */\nfunction flatten(arr) {\n    var _a;\n    return (_a = []).concat.apply(_a, arr);\n}\n\n\n//# sourceURL=webpack://grist/./node_modules/ts-interface-checker/dist/util.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack://grist/(webpack)/buildin/global.js?");

/***/ })

/******/ });